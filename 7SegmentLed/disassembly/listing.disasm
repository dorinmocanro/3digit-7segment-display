Disassembly Listing for test_7segment
Generated From:
C:/Users/dorin/Desktop/7SegmentLed/dist/second_default/production/7SegmentLed.production.elf
Apr 23, 2019 10:21:15 PM

---  C:/Users/dorin/Desktop/7SegmentLed/main.c  ---------------------------------------------------------
1:             /* 
2:              * File:   main.c
3:              * Author: dorin
4:              *
5:              * Created on 04 aprilie 2019, 15:44
6:              */
7:             
8:             #include <xc.h>
9:             #include "config.h"
10:            #include <stdio.h>
11:            #include <stdlib.h>
12:            #include <string.h>
13:            
14:            
15:            #define _XTAL_FREQ 8000000
16:            
17:            typedef const unsigned char POZ;
18:            POZ SER=0x01;
19:            POZ SRCLK=0x01<<1;
2906  828A     BSF LATB, 1, ACCESS
20:            POZ SRCLR=0x01<<2;
28E2  848A     BSF LATB, 2, ACCESS
21:            POZ RCLK=0x01<<4;
22:            POZ OE=0x01<<3;
26B4  868A     BSF LATB, 3, ACCESS
23:            /*
24:            digits needs to be in sequence: like so:
25:            POZ DIG1=0x20;
26:            POZ DIG2=0x40;
27:            POZ DIG3=0x80;
28:             */
29:            
30:            POZ DIG1=0x20;
2620  0E20     MOVLW 0x20
2622  6E0C     MOVWF fp, ACCESS
31:            POZ DIG2=0x40;
32:            POZ DIG3=0x80;
33:            /*
34:             * for __delay_ms(unsigned) or __delay_us(unsigned)
35:             */
36:            
37:            
38:            //setup porta
39:            void setupPA(void){
40:                //initializare PORTA pentru afisaj-7segment 
41:                PORTA=0x00; //sterge tot 
42:                ADCON1=0x0f;
43:                CMCON=0x07;
44:             //   TRISA=0xff; //  Start cu toti pinii in stare high-impedance 
45:                
46:            }
47:            
48:            void setupPB(){
49:                PORTB=0x00;
2BA4  0E00     MOVLW 0x0
2BA6  6E81     MOVWF PORTB, ACCESS
50:                ADCON1=0x0F;    // everything is digital, 
2BA8  0E0F     MOVLW 0xF
2BAA  6EC1     MOVWF ADCON1, ACCESS
51:                                // may be needed to modify
52:                                // to modify only this port
53:                TRISB=0x00;      //everything is an output
2BAC  0E00     MOVLW 0x0
2BAE  6E93     MOVWF TRISB, ACCESS
54:                OSCCON=0b01110000; //8MHz. internal 
2BB0  0E70     MOVLW 0x70
2BB2  6ED3     MOVWF OSCCON, ACCESS
55:            }
2BB4  0012     RETURN 0
56:            
57:            void send_digit(unsigned char );
58:            unsigned char character_table(unsigned char);
59:            
60:            //this function defines each led and return a symbol char for send_digit
61:            unsigned char character_table(unsigned char symbol){
222E  6E03     MOVWF fp, ACCESS
62:                typedef const unsigned char c_t;  //character type c_t
63:                //assign to eatch LED a bit:
64:                c_t o=0x00; //define 'o' as zero / off
65:                c_t a=0x01;
2266  0E07     MOVLW 0x7
2268  0012     RETURN 0
66:                c_t b=0x01<<1;
67:                c_t c=0x01<<2;
68:                c_t d=0x01<<3;
69:                c_t e=0x01<<4;
70:                c_t f=0x01<<5;
71:                c_t g=0x01<<6;
72:                c_t h=0x01<<7;  // the dot LED
73:                
74:                //defining characters
75:                switch (symbol){
2230  D030     BRA 0x2292
76:                    //  |h will deactivate the implicit "dot" on NOT (EXPRESION);
77:                    case 'a': return ~(d|h);
2232  0E77     MOVLW 0x77
2234  0012     RETURN 0
78:                    case 'b': return ~(a|c|h);
2236  0E7A     MOVLW 0x7A
2238  0012     RETURN 0
79:                    //case 'b':return b|d|e|f|g;
80:                    case 'c': return ~(b|c|e|h) ;
223A  0E69     MOVLW 0x69
223C  0012     RETURN 0
81:                    case 'd': return ~(a|g |h);
223E  0E3E     MOVLW 0x3E
2240  0012     RETURN 0
82:                    case 'e': return ~(b|c |h) ;
2242  0E79     MOVLW 0x79
2244  0012     RETURN 0
83:                    case 'f': return ~(b|c|d |h);
2246  0E71     MOVLW 0x71
2248  0012     RETURN 0
84:                    case '0': return ~(e |h);
224A  0E6F     MOVLW 0x6F
224C  0012     RETURN 0
85:                    case '1': return b|c;
224E  0E06     MOVLW 0x6
2250  0012     RETURN 0
86:                    case '2': return ~(b|g |h);
2252  0E3D     MOVLW 0x3D
2254  0012     RETURN 0
87:                    case '3': return ~(f|g |h);
2256  0E1F     MOVLW 0x1F
2258  0012     RETURN 0
88:                    case '4': return ~(a|d|f |h);
225A  0E56     MOVLW 0x56
225C  0012     RETURN 0
89:                    case '5': return ~(c|f |h) ;
225E  0E5B     MOVLW 0x5B
2260  0012     RETURN 0
90:                    case '6': return ~ (c |h);
2262  0E7B     MOVLW 0x7B
2264  0012     RETURN 0
91:                    case '7': return a|b|c;
92:                    case '8': return ~(o |h);
226A  0E7F     MOVLW 0x7F
226C  0012     RETURN 0
93:                    case '9': return ~(f |h);
226E  0E5F     MOVLW 0x5F
2270  0012     RETURN 0
94:                    case '.': return h;
2272  0E03     MOVLW 0x3
2274  6EF6     MOVWF TBLPTR, ACCESS
2276  0E08     MOVLW 0x8
2278  6EF7     MOVWF TBLPTRH, ACCESS
227A  0008     TBLRD*
227C  50F5     MOVF TABLAT, W, ACCESS
227E  0012     RETURN 0
95:                    case 0  : return o; //digit# off
2280  0E0B     MOVLW 0xB
2282  6EF6     MOVWF TBLPTR, ACCESS
2284  0E08     MOVLW 0x8
2286  6EF7     MOVWF TBLPTRH, ACCESS
2288  0008     TBLRD*
228A  50F5     MOVF TABLAT, W, ACCESS
228C  0012     RETURN 0
96:                    case 'o': return o; //Digit# off
97:                    default: return  ~(b|d); // "P"
228E  0EF5     MOVLW 0xF5
2290  0012     RETURN 0
98:                }
2292  5003     MOVF fp, W, ACCESS
2294  6E01     MOVWF __pcstackCOMRAM, ACCESS
2296  6A02     CLRF 0x2, ACCESS
2298  5002     MOVF 0x2, W, ACCESS
229A  0A00     XORLW 0x0
229C  A4D8     BTFSS STATUS, 2, ACCESS
229E  D7F7     BRA 0x228E
22A0  5001     MOVF __pcstackCOMRAM, W, ACCESS
22A2  0A00     XORLW 0x0
22A4  B4D8     BTFSC STATUS, 2, ACCESS
22A6  D7EC     BRA 0x2280
22A8  0A2E     XORLW 0x2E
22AA  B4D8     BTFSC STATUS, 2, ACCESS
22AC  D7E2     BRA 0x2272
22AE  0A1E     XORLW 0x1E
22B0  B4D8     BTFSC STATUS, 2, ACCESS
22B2  D7CB     BRA 0x224A
22B4  0A01     XORLW 0x1
22B6  B4D8     BTFSC STATUS, 2, ACCESS
22B8  D7CA     BRA 0x224E
22BA  0A03     XORLW 0x3
22BC  B4D8     BTFSC STATUS, 2, ACCESS
22BE  D7C9     BRA 0x2252
22C0  0A01     XORLW 0x1
22C2  B4D8     BTFSC STATUS, 2, ACCESS
22C4  D7C8     BRA 0x2256
22C6  0A07     XORLW 0x7
22C8  B4D8     BTFSC STATUS, 2, ACCESS
22CA  D7C7     BRA 0x225A
22CC  0A01     XORLW 0x1
22CE  B4D8     BTFSC STATUS, 2, ACCESS
22D0  D7C6     BRA 0x225E
22D2  0A03     XORLW 0x3
22D4  B4D8     BTFSC STATUS, 2, ACCESS
22D6  D7C5     BRA 0x2262
22D8  0A01     XORLW 0x1
22DA  B4D8     BTFSC STATUS, 2, ACCESS
22DC  D7C4     BRA 0x2266
22DE  0A0F     XORLW 0xF
22E0  B4D8     BTFSC STATUS, 2, ACCESS
22E2  D7C3     BRA 0x226A
22E4  0A01     XORLW 0x1
22E6  B4D8     BTFSC STATUS, 2, ACCESS
22E8  D7C2     BRA 0x226E
22EA  0A58     XORLW 0x58
22EC  B4D8     BTFSC STATUS, 2, ACCESS
22EE  D7A1     BRA 0x2232
22F0  0A03     XORLW 0x3
22F2  B4D8     BTFSC STATUS, 2, ACCESS
22F4  D7A0     BRA 0x2236
22F6  0A01     XORLW 0x1
22F8  B4D8     BTFSC STATUS, 2, ACCESS
22FA  D79F     BRA 0x223A
22FC  0A07     XORLW 0x7
22FE  B4D8     BTFSC STATUS, 2, ACCESS
2300  D79E     BRA 0x223E
2302  0A01     XORLW 0x1
2304  B4D8     BTFSC STATUS, 2, ACCESS
2306  D79D     BRA 0x2242
2308  0A03     XORLW 0x3
230A  B4D8     BTFSC STATUS, 2, ACCESS
230C  D79C     BRA 0x2246
230E  0A09     XORLW 0x9
2310  B4D8     BTFSC STATUS, 2, ACCESS
2312  D7B6     BRA 0x2280
2314  D7BC     BRA 0x228E
99:               
100:               
101:           }
102:           
103:           //helper functions (needed for better sincronisation with digit shift/select)
104:           //the "inline instruction does not create an inline function... 
105:            //data ready, but deactivate output
106:               //REG =  xxx0 000   and set  0001 1000
107:           
108:           //send data, but do not activate the OUTPUT
109:           #define data_ready()  LATB=(LATB & ~(SER|SRCLK|SRCLR|RCLK)) | RCLK;\
110:                                  LATB=(LATB & ~(SER|SRCLK|SRCLR|RCLK));
111:           #define output_enable()    LATB&=~OE //LATBbits.LB4=0;
112:           #define output_disable()   LATB |=OE //LATBbits.LB4=1;
113:           
114:           void send_digit(unsigned char data){
28DC  6E04     MOVWF data, ACCESS
115:               unsigned  char a;
116:               POZ com_mask=SER|SRCLK|SRCLR|RCLK ;  //a sum of all interface pins. for masking
117:               LATB&=~com_mask; // 1110.000 bitwise AND. clear the comunication pins
28DE  0EE8     MOVLW 0xE8
28E0  168A     ANDWF LATB, F, ACCESS
118:                           // ( output (/OE) is set to '0' ==? ENABLED (default))
119:                           //0xF* /OE is 1 => output is off
120:               LATB|=SRCLR; // exit the clear state (/SRCLR =/1)
121:               //PORTBbits.RB2=1; //need to add this instr in the above instr.. (testing?))
122:               for(int i=0;i<8; i++ )// shift right/left 8x times
28E4  0E00     MOVLW 0x0
28E6  6E02     MOVWF 0x2, ACCESS
28E8  0E00     MOVLW 0x0
28EA  6E01     MOVWF __pcstackCOMRAM, ACCESS
123:               {
124:                   //rotate data first , so in RB0 you have the data's MSBit
125:                   data= (data<<1) | (data>>7);
28EC  90D8     BCF STATUS, 0, ACCESS
28EE  3404     RLCF data, W, ACCESS
28F0  3404     RLCF data, W, ACCESS
28F2  6E04     MOVWF data, ACCESS
126:                   a=LATB & ~(SER|SRCLK); //read portB to a, and clear the last 2 bits (==0))
28F4  508A     MOVF LATB, W, ACCESS
28F6  0BFC     ANDLW 0xFC
28F8  6E03     MOVWF fp, ACCESS
127:                                   //clears CLOCK and Data bit (SER) 
128:                   a =a| (data & SER); // copy the data's last bit  (data:0) into a
28FA  5004     MOVF data, W, ACCESS
28FC  0B01     ANDLW 0x1
28FE  1003     IORWF fp, W, ACCESS
2900  6E03     MOVWF fp, ACCESS
129:                   LATB=a;
2902  C003     MOVFF fp, LATB
2904  FF8A     NOP
130:                   LATB|=SRCLK;
131:           /*   
132:                   //data>>=1;   //deplasare spre dreapta
133:                   //this formula will correctly rotate left (towards LSBit)
134:                   //data= (data<<1) | (data>>7);
135:           */
136:               }
2908  4A01     INFSNZ __pcstackCOMRAM, F, ACCESS
290A  2A02     INCF 0x2, F, ACCESS
290C  BE02     BTFSC 0x2, 7, ACCESS
290E  D7EE     BRA 0x28EC
2910  5002     MOVF 0x2, W, ACCESS
2912  E105     BNZ 0x291E
2914  0E08     MOVLW 0x8
2916  5C01     SUBWF __pcstackCOMRAM, W, ACCESS
2918  B0D8     BTFSC STATUS, 0, ACCESS
291A  0012     RETURN 0
291C  D7E7     BRA 0x28EC
137:               //send data, but do not activate the OUTPUT
138:               //...missing. it is added on the parent/caller function
139:           }
291E  0012     RETURN 0
140:           
141:           
142:           //this function depends heavily on PORTB
143:           //all the pins are used. so it may be needed to change this function
144:           //in the future
145:           //the 3 Most Significant Bits are used for multiplexing.!!!
146:           void display3(const char* data3){
147:           #define MAX_DIGIT 3 
148:               const unsigned char 
149:                   dig_mask= ~(DIG1 | DIG2 | DIG3); //0x1f  by default 
150:               // this _SHIFT_LEFT_will right-justify the characters
151:               unsigned char csize=strlen(data3);   
2610  C005     MOVFF product, __pcstackCOMRAM
2612  F001     NOP
2614  C006     MOVFF 0x6, 0x2
2616  F002     NOP
2618  EC99     CALL 0x2B32, 0
261A  F015     NOP
261C  5001     MOVF __pcstackCOMRAM, W, ACCESS
261E  6E0B     MOVWF csize, ACCESS
152:               volatile unsigned char bit=DIG1;
153:               bit= (bit<<(MAX_DIGIT-csize)) | (bit>>(8-MAX_DIGIT+csize)); 
2624  C00B     MOVFF csize, c
2626  F007     NOP
2628  0E05     MOVLW 0x5
262A  2607     ADDWF c, F, ACCESS
262C  C00C     MOVFF fp, s
262E  F008     NOP
2630  2A07     INCF c, F, ACCESS
2632  D002     BRA 0x2638
2634  90D8     BCF STATUS, 0, ACCESS
2636  3208     RRCF s, F, ACCESS
2638  2E07     DECFSZ c, F, ACCESS
263A  D7FC     BRA 0x2634
263C  500B     MOVF csize, W, ACCESS
263E  0803     SUBLW 0x3
2640  6E09     MOVWF divisor, ACCESS
2642  C00C     MOVFF fp, s
2644  F00A     NOP
2646  2A09     INCF divisor, F, ACCESS
2648  D002     BRA 0x264E
264A  90D8     BCF STATUS, 0, ACCESS
264C  360A     RLCF s, F, ACCESS
264E  2E09     DECFSZ divisor, F, ACCESS
2650  D7FC     BRA 0x264A
2652  500A     MOVF s, W, ACCESS
2654  1008     IORWF s, W, ACCESS
2656  D01E     BRA 0x2694
154:               // ^skip 1 or 2 digits from MSB, RIGHT_JUSTIFY
155:             
156:               //bit it is shifted to the left by 1.
157:               //Ensure bit is in the range of the defined DIG#
158:               // no need to check for NULL character; `csize' (above) takes care.
159:               while( bit & (DIG1|DIG2|DIG3) )    { 
2696  C00C     MOVFF fp, c
2698  F007     NOP
269A  0EE0     MOVLW 0xE0
269C  1607     ANDWF c, F, ACCESS
269E  A4D8     BTFSS STATUS, 2, ACCESS
26A0  D7DB     BRA 0x2658
160:                   output_enable();    //just in case this is disabled. NB: /OE may create ghosting
2658  968A     BCF LATB, 3, ACCESS
161:                   send_digit(  character_table(*(data3++))  ); //ideea: |character_table('.')
265A  C005     MOVFF product, FSR2
265C  FFD9     NOP
265E  C006     MOVFF 0x6, FSR2H
2660  FFDA     NOP
2662  50DF     MOVF INDF2, W, ACCESS
2664  EC17     CALL 0x222E, 0
2666  F011     NOP
2668  EC6E     CALL 0x28DC, 0
266A  F014     NOP
266C  4A05     INFSNZ product, F, ACCESS
266E  2A06     INCF 0x6, F, ACCESS
162:                   //send_digit(character_table('.'))
163:                   
164:                   LATB=(LATB & dig_mask);//clear the 3 MSB.  aka Output off
2670  508A     MOVF LATB, W, ACCESS
2672  0B1F     ANDLW 0x1F
2674  6E8A     MOVWF LATB, ACCESS
165:                   data_ready();
2676  508A     MOVF LATB, W, ACCESS
2678  0BE8     ANDLW 0xE8
267A  0910     IORLW 0x10
267C  6E8A     MOVWF LATB, ACCESS
267E  508A     MOVF LATB, W, ACCESS
2680  0BE8     ANDLW 0xE8
2682  6E8A     MOVWF LATB, ACCESS
166:                   __delay_us(30);  //wait for inductive R (prevent ghosting))        
2684  0E14     MOVLW 0x14
2686  2EE8     DECFSZ WREG, F, ACCESS
2688  D7FE     BRA 0x2686
167:                   LATB|= bit; // and set the new bit (that was shifted to the left))
268A  500C     MOVF fp, W, ACCESS
268C  128A     IORWF LATB, F, ACCESS
168:                   //set bit 1,2 or 3 and increment (shift) to next bit)
169:                   bit = (bit<<1)|(bit>>7);    //shift left 
268E  90D8     BCF STATUS, 0, ACCESS
2690  340C     RLCF fp, W, ACCESS
2692  340C     RLCF fp, W, ACCESS
2694  6E0C     MOVWF fp, ACCESS
170:                  //  bit= (bit>>1)| (bit<<7);
171:                   
172:               }
173:               //this function ensures the same duty cycle for all 3 DIGItS
174:               //an oscilloscope may be used here to see (for my case is approx 19,3%)
175:               send_digit("o");__delay_us(30); LATB=(LATB & dig_mask);
26A2  0E26     MOVLW 0x26
26A4  EC6E     CALL 0x28DC, 0
26A6  F014     NOP
26A8  0E14     MOVLW 0x14
26AA  2EE8     DECFSZ WREG, F, ACCESS
26AC  D7FE     BRA 0x26AA
26AE  508A     MOVF LATB, W, ACCESS
26B0  0B1F     ANDLW 0x1F
26B2  6E8A     MOVWF LATB, ACCESS
176:               output_disable();
177:               
178:           }
26B6  0012     RETURN 0
179:           
180:           
181:           
182:           typedef unsigned char BIT_MASK;
183:           BIT_MASK BIT_0=0x01;
184:           BIT_MASK BIT_1=0x01<<1;
185:           BIT_MASK BIT_2=0x01<<2;
186:           BIT_MASK BIT_3=0x01<<3;
187:           BIT_MASK BIT_4=0x01<<4;
188:           BIT_MASK BIT_5=0x01<<5;
189:           BIT_MASK BIT_6=0x01<<6;
190:           BIT_MASK BIT_7=0x01<<7;
191:           
192:           
193:           
194:           //trying to write an ISR (no priority)
195:           void __interrupt(high_priority) my_ISR(){
0008  825F     BSF btemp, 1, ACCESS
2B82  0006     POP
196:               //check if timer TMR0 overflowed
197:               //if(TMR0IE);       //blah.. i prefer using masks
198:               if( (INTCON & BIT_5) && (INTCON & BIT_3) ){
2B84  50F2     MOVF INTCON, W, ACCESS
199:                   //clear timer 0 Flag
200:                   INTCON &=~BIT_3;
2B9A  51D1     MOVF BIT_3, W, BANKED
201:               }
202:           }
2BA0  925F     BCF btemp, 1, ACCESS
203:           
204:           
205:           int main(int argc, char** argv) {
206:               //setupPA();
207:               setupPB();
299C  ECD2     CALL 0x2BA4, 0
299E  F015     NOP
208:               unsigned int nr=123;
209:               char buffer[4];
210:               snprintf(buffer,4,"%d",nr);
29A0  0E9A     MOVLW 0x9A
29A2  0100     MOVLB 0x0
29A4  6F8D     MOVWF s, BANKED
29A6  0E00     MOVLW 0x0
29A8  6F8E     MOVWF 0x8E, BANKED
29AA  0E00     MOVLW 0x0
29AC  6F90     MOVWF 0x90, BANKED
29AE  0E04     MOVLW 0x4
29B0  6F8F     MOVWF n, BANKED
29B2  0E45     MOVLW 0x45
29B4  6F91     MOVWF fmt, BANKED
29B6  0E08     MOVLW 0x8
29B8  6F92     MOVWF 0x92, BANKED
29BA  0E00     MOVLW 0x0
29BC  6F94     MOVWF 0x94, BANKED
29BE  0E7B     MOVLW 0x7B
29C0  6F93     MOVWF 0x93, BANKED
29C2  EC39     CALL 0x2A72, 0
29C4  F015     NOP
211:               //buffer[3]=0;
212:               //buffer[0]=strlen(buffer)+'0';
213:               
214:           
215:               while (1){
216:                   display3(buffer); //__delay_ms(30);
29C6  0E9A     MOVLW 0x9A
29C8  6E05     MOVWF product, ACCESS
29CA  0E00     MOVLW 0x0
29CC  6E06     MOVWF 0x6, ACCESS
29CE  EC08     CALL 0x2610, 0
29D0  F013     NOP
29D2  D7F9     BRA 0x29C6
217:           
218:               }  
219:               while(1){
220:                   LATB^=0x20; __delay_us(1);
221:               
222:                   CLRWDT();   //this is disabled by me in config.h
223:               } // hold in here
224:               return (EXIT_SUCCESS);
225:           }
226:           
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/toupper.c  -----------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             
4:             int toupper(int c)
5:             {
6:             	if (islower(c)) return c & 0x5f;
2892  0E9F     MOVLW 0x9F
2894  6E09     MOVWF divisor, ACCESS
2896  0EFF     MOVLW 0xFF
2898  6E0A     MOVWF s, ACCESS
289A  C007     MOVFF c, csize
289C  F00B     NOP
289E  C008     MOVFF s, fp
28A0  F00C     NOP
28A2  5009     MOVF divisor, W, ACCESS
28A4  260B     ADDWF csize, F, ACCESS
28A6  500A     MOVF s, W, ACCESS
28A8  220C     ADDWFC fp, F, ACCESS
28AA  500C     MOVF fp, W, ACCESS
28AC  E106     BNZ 0x28BA
28AE  0E1A     MOVLW 0x1A
28B0  5C0B     SUBWF csize, W, ACCESS
28B2  B0D8     BTFSC STATUS, 0, ACCESS
28B4  D002     BRA 0x28BA
28B6  0E01     MOVLW 0x1
28B8  D001     BRA 0x28BC
28BA  0E00     MOVLW 0x0
28BC  6E0D     MOVWF 0xD, ACCESS
28BE  6A0E     CLRF c, ACCESS
28C0  500D     MOVF 0xD, W, ACCESS
28C2  100E     IORWF c, W, ACCESS
28C4  B4D8     BTFSC STATUS, 2, ACCESS
28C6  D005     BRA 0x28D2
28C8  0E5F     MOVLW 0x5F
28CA  1407     ANDWF c, W, ACCESS
28CC  6E07     MOVWF c, ACCESS
28CE  6A08     CLRF s, ACCESS
28D0  0012     RETURN 0
7:             	return c;
28D2  C007     MOVFF c, c
28D4  F007     NOP
28D6  C008     MOVFF s, s
28D8  F008     NOP
8:             }
28DA  0012     RETURN 0
9:             
10:            int __toupper_l(int c, locale_t l)
11:            {
12:            	return toupper(c);
13:            }
14:            
15:            weak_alias(__toupper_l, toupper_l);
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/strncmp.c  -----------------------
1:             #include <string.h>
2:             
3:             int strncmp(const char *_l, const char *_r, size_t n)
4:             {
5:             	const unsigned char *l=(void *)_l, *r=(void *)_r;
2566  C001     MOVFF __pcstackCOMRAM, s
2568  F008     NOP
256A  C002     MOVFF 0x2, divisor
256C  F009     NOP
256E  C003     MOVFF fp, s
2570  F00A     NOP
2572  C004     MOVFF data, csize
2574  F00B     NOP
6:             	if (!n--) return 0;
2576  0605     DECF product, F, ACCESS
2578  A0D8     BTFSS STATUS, 0, ACCESS
257A  0606     DECF 0x6, F, ACCESS
257C  2805     INCF product, W, ACCESS
257E  E10F     BNZ 0x259E
2580  2806     INCF 0x6, W, ACCESS
2582  A4D8     BTFSS STATUS, 2, ACCESS
2584  D00C     BRA 0x259E
2586  0E00     MOVLW 0x0
2588  6E02     MOVWF 0x2, ACCESS
258A  0E00     MOVLW 0x0
258C  6E01     MOVWF __pcstackCOMRAM, ACCESS
258E  0012     RETURN 0
7:             	for (; *l && *r && n && *l == *r ; l++, r++, n--);
2590  4A08     INFSNZ s, F, ACCESS
2592  2A09     INCF divisor, F, ACCESS
2594  4A0A     INFSNZ s, F, ACCESS
2596  2A0B     INCF csize, F, ACCESS
2598  0605     DECF product, F, ACCESS
259A  A0D8     BTFSS STATUS, 0, ACCESS
259C  0606     DECF 0x6, F, ACCESS
259E  C008     MOVFF s, TBLPTR
25A0  FFF6     NOP
25A2  C009     MOVFF divisor, TBLPTRH
25A4  FFF7     NOP
25A6  0008     TBLRD*
25A8  50F5     MOVF TABLAT, W, ACCESS
25AA  0900     IORLW 0x0
25AC  B4D8     BTFSC STATUS, 2, ACCESS
25AE  D01D     BRA 0x25EA
25B0  C00A     MOVFF s, TBLPTR
25B2  FFF6     NOP
25B4  C00B     MOVFF csize, TBLPTRH
25B6  FFF7     NOP
25B8  0008     TBLRD*
25BA  50F5     MOVF TABLAT, W, ACCESS
25BC  0900     IORLW 0x0
25BE  B4D8     BTFSC STATUS, 2, ACCESS
25C0  D014     BRA 0x25EA
25C2  5005     MOVF product, W, ACCESS
25C4  1006     IORWF 0x6, W, ACCESS
25C6  B4D8     BTFSC STATUS, 2, ACCESS
25C8  D010     BRA 0x25EA
25CA  C008     MOVFF s, TBLPTR
25CC  FFF6     NOP
25CE  C009     MOVFF divisor, TBLPTRH
25D0  FFF7     NOP
25D2  0008     TBLRD*
25D4  CFF5     MOVFF TABLAT, c
25D6  F007     NOP
25D8  C00A     MOVFF s, TBLPTR
25DA  FFF6     NOP
25DC  C00B     MOVFF csize, TBLPTRH
25DE  FFF7     NOP
25E0  0008     TBLRD*
25E2  50F5     MOVF TABLAT, W, ACCESS
25E4  1807     XORWF c, W, ACCESS
25E6  B4D8     BTFSC STATUS, 2, ACCESS
25E8  D7D3     BRA 0x2590
8:             	return *l - *r;
25EA  C008     MOVFF s, TBLPTR
25EC  FFF6     NOP
25EE  C009     MOVFF divisor, TBLPTRH
25F0  FFF7     NOP
25F2  0008     TBLRD*
25F4  CFF5     MOVFF TABLAT, c
25F6  F007     NOP
25F8  C00A     MOVFF s, TBLPTR
25FA  FFF6     NOP
25FC  C00B     MOVFF csize, TBLPTRH
25FE  FFF7     NOP
2600  0008     TBLRD*
2602  50F5     MOVF TABLAT, W, ACCESS
2604  5C07     SUBWF c, W, ACCESS
2606  6E01     MOVWF __pcstackCOMRAM, ACCESS
2608  6A02     CLRF 0x2, ACCESS
260A  A0D8     BTFSS STATUS, 0, ACCESS
260C  0602     DECF 0x2, F, ACCESS
9:             }
260E  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/strlen.c  ------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             #include <limits.h>
4:             
5:             #ifndef __XC8__
6:             #define ALIGN (sizeof(size_t))
7:             #define ONES ((size_t)-1/UCHAR_MAX)
8:             #define HIGHS (ONES * (UCHAR_MAX/2+1))
9:             #define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)
10:            #endif
11:            
12:            size_t strlen(const char *s)
13:            {
14:            	const char *a = s;
2B32  C001     MOVFF __pcstackCOMRAM, fp
2B34  F003     NOP
2B36  C002     MOVFF 0x2, data
2B38  F004     NOP
15:            #ifdef __XC8__
16:            	while(*s) {
2B3A  D002     BRA 0x2B40
2B40  C001     MOVFF __pcstackCOMRAM, FSR2
2B42  FFD9     NOP
2B44  C002     MOVFF 0x2, FSR2H
2B46  FFDA     NOP
2B48  50DF     MOVF INDF2, W, ACCESS
2B4A  A4D8     BTFSS STATUS, 2, ACCESS
2B4C  D7F7     BRA 0x2B3C
17:            		s++;
2B3C  4A01     INFSNZ __pcstackCOMRAM, F, ACCESS
2B3E  2A02     INCF 0x2, F, ACCESS
18:            	}
19:            #else
20:            	const size_t *w;
21:            	for (; (uintptr_t)s % ALIGN; s++) if (!*s) return s-a;
22:            	for (w = (const void *)s; !HASZERO(*w); w++);
23:            	for (s = (const void *)w; *s; s++);
24:            #endif
25:            	return s-a;
2B4E  5003     MOVF fp, W, ACCESS
2B50  5C01     SUBWF __pcstackCOMRAM, W, ACCESS
2B52  6E01     MOVWF __pcstackCOMRAM, ACCESS
2B54  5004     MOVF data, W, ACCESS
2B56  5802     SUBWFB 0x2, W, ACCESS
2B58  6E02     MOVWF 0x2, ACCESS
26:            }
2B5A  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/snprintf.c  ----------------------
1:             #include <stdio.h>
2:             #include <stdarg.h>
3:             
4:             int snprintf(char *restrict s, size_t n, const char *restrict fmt, ...)
5:             {
6:             	int ret;
7:             	va_list ap;
8:             	va_start(ap, fmt);
2A72  0E93     MOVLW 0x93
2A74  6E5B     MOVWF ap, ACCESS
2A76  0E00     MOVLW 0x0
2A78  6E5C     MOVWF 0x5C, ACCESS
9:             	ret = vsnprintf(s, n, fmt, ap);
2A7A  C08D     MOVFF s, s
2A7C  F07B     NOP
2A7E  C08E     MOVFF 0x8E, 0x7C
2A80  F07C     NOP
2A82  C08F     MOVFF n, n
2A84  F07D     NOP
2A86  C090     MOVFF 0x90, 0x7E
2A88  F07E     NOP
2A8A  C091     MOVFF fmt, fmt
2A8C  F07F     NOP
2A8E  C092     MOVFF 0x92, 0x80
2A90  F080     NOP
2A92  0E5B     MOVLW 0x5B
2A94  0100     MOVLB 0x0
2A96  6F81     MOVWF ap, BANKED
2A98  0E00     MOVLW 0x0
2A9A  6F82     MOVWF 0x82, BANKED
2A9C  EC8B     CALL 0x2316, 0
2A9E  F011     NOP
10:            	va_end(ap);
11:            	return ret;
12:            }
2AA0  0012     RETURN 0
13:            
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/putch.c  -------------------------
1:             /*
2:              * Function: putch
3:              * Weak implementation.  User implementation may be required
4:              */
5:             
6:             void 
7:             putch(char c)
8:             {
9:             }
2BC6  0012     RETURN 0
10:            
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/nf_vsnprintf.c  ------------------
1:             #include "stdio_impl.h"
2:             #include <limits.h>
3:             #include <string.h>
4:             #include <errno.h>
5:             #include <stdint.h>
6:             
7:             #ifdef STDIO_NO_FILE_IO
8:             
9:             #define MIN(a, b) ((a) < (b) ? (a) : (b))
10:            
11:            int vsnprintf(char *restrict s, size_t n, const char *restrict fmt, va_list ap)
12:            {
13:            	int cnt;
14:            	FILE f;
15:            
16:            	if (n > INT_MAX) {
2316  0E80     MOVLW 0x80
2318  0100     MOVLB 0x0
231A  5D7E     SUBWF 0x7E, W, BANKED
231C  A0D8     BTFSS STATUS, 0, ACCESS
231E  D007     BRA 0x232E
17:            		errno = EOVERFLOW;
2320  0E00     MOVLW 0x0
2322  6F9F     MOVWF 0x9F, BANKED
2324  0E4B     MOVLW 0x4B
2326  6F9E     MOVWF errno, BANKED
18:            		return -1;
2328  697B     SETF s, BANKED
232A  697C     SETF 0x7C, BANKED
232C  0012     RETURN 0
19:            	}
20:            	f.buffer = s;
232E  C07B     MOVFF s, f
2330  F087     NOP
2332  C07C     MOVFF 0x7C, 0x88
2334  F088     NOP
21:            	if(n>1) {
2336  517E     MOVF 0x7E, W, BANKED
2338  E104     BNZ 0x2342
233A  0E02     MOVLW 0x2
233C  5D7D     SUBWF n, W, BANKED
233E  A0D8     BTFSS STATUS, 0, ACCESS
2340  D00A     BRA 0x2356
22:            		f.limit = n-1;
2342  0EFF     MOVLW 0xFF
2344  257D     ADDWF n, W, BANKED
2346  6F8B     MOVWF 0x8B, BANKED
2348  0EFF     MOVLW 0xFF
234A  217E     ADDWFC 0x7E, W, BANKED
234C  6F8C     MOVWF 0x8C, BANKED
23:            		f.count = 0;
234E  0E00     MOVLW 0x0
2350  6F8A     MOVWF 0x8A, BANKED
2352  0E00     MOVLW 0x0
2354  D007     BRA 0x2364
24:            	}
25:            	else {
26:            		f.limit = 1;
2356  0E00     MOVLW 0x0
2358  6F8C     MOVWF 0x8C, BANKED
235A  0E01     MOVLW 0x1
235C  6F8B     MOVWF 0x8B, BANKED
27:            		f.count = 1;
235E  0E00     MOVLW 0x0
2360  6F8A     MOVWF 0x8A, BANKED
2362  0E01     MOVLW 0x1
2364  6F89     MOVWF 0x89, BANKED
28:            	}
29:            	cnt = vfprintf(&f, fmt, ap);
2366  0E87     MOVLW 0x87
2368  6E4D     MOVWF fp, ACCESS
236A  0E00     MOVLW 0x0
236C  6E4E     MOVWF 0x4E, ACCESS
236E  C07F     MOVFF fmt, fmt
2370  F04F     NOP
2372  C080     MOVFF 0x80, 0x50
2374  F050     NOP
2376  C081     MOVFF ap, ap
2378  F051     NOP
237A  C082     MOVFF 0x82, 0x52
237C  F052     NOP
237E  ECF7     CALL 0x27EE, 0
2380  F013     NOP
2382  C04D     MOVFF fp, cnt
2384  F085     NOP
2386  C04E     MOVFF 0x4E, 0x86
2388  F086     NOP
30:            	if((n>0) && (cnt>=0)) {
238A  0100     MOVLB 0x0
238C  517D     MOVF n, W, BANKED
238E  117E     IORWF 0x7E, W, BANKED
2390  A4D8     BTFSS STATUS, 2, ACCESS
2392  BF86     BTFSC 0x86, 7, BANKED
2394  D025     BRA 0x23E0
31:            		s[MIN(cnt, n-1)] = '\0';
2396  0EFF     MOVLW 0xFF
2398  6E55     MOVWF 0x55, ACCESS
239A  0EFF     MOVLW 0xFF
239C  6E56     MOVWF 0x56, ACCESS
239E  C07D     MOVFF n, 0x57
23A0  F057     NOP
23A2  C07E     MOVFF 0x7E, 0x58
23A4  F058     NOP
23A6  5055     MOVF 0x55, W, ACCESS
23A8  2657     ADDWF 0x57, F, ACCESS
23AA  5056     MOVF 0x56, W, ACCESS
23AC  2258     ADDWFC 0x58, F, ACCESS
23AE  5057     MOVF 0x57, W, ACCESS
23B0  5D85     SUBWF cnt, W, BANKED
23B2  5058     MOVF 0x58, W, ACCESS
23B4  5986     SUBWFB 0x86, W, BANKED
23B6  A0D8     BTFSS STATUS, 0, ACCESS
23B8  D007     BRA 0x23C8
23BA  0EFF     MOVLW 0xFF
23BC  257D     ADDWF n, W, BANKED
23BE  6F83     MOVWF 0x83, BANKED
23C0  0EFF     MOVLW 0xFF
23C2  217E     ADDWFC 0x7E, W, BANKED
23C4  6F84     MOVWF 0x84, BANKED
23C6  D004     BRA 0x23D0
23C8  C085     MOVFF cnt, 0x83
23CA  F083     NOP
23CC  C086     MOVFF 0x86, 0x84
23CE  F084     NOP
23D0  5183     MOVF 0x83, W, BANKED
23D2  257B     ADDWF s, W, BANKED
23D4  6ED9     MOVWF FSR2, ACCESS
23D6  5184     MOVF 0x84, W, BANKED
23D8  217C     ADDWFC 0x7C, W, BANKED
23DA  6EDA     MOVWF FSR2H, ACCESS
23DC  0E00     MOVLW 0x0
23DE  6EDF     MOVWF INDF2, ACCESS
32:            	}
33:            	return cnt;
23E0  C085     MOVFF cnt, s
23E2  F07B     NOP
23E4  C086     MOVFF 0x86, 0x7C
23E6  F07C     NOP
34:            }
23E8  0012     RETURN 0
35:            #endif
36:            
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/nf_fputs.c  ----------------------
1:             /* "No file system" fputs */
2:             #include <stdio.h>
3:             
4:             #include "stdio_impl.h"
5:             
6:             #ifdef STDIO_NO_FILE_IO
7:             
8:             int fputs(const char *s, FILE *fp)
9:             {
10:                char c;
11:                int i;
12:            
13:                i = 0;
29D4  0E00     MOVLW 0x0
29D6  6E10     MOVWF 0x10, ACCESS
29D8  0E00     MOVLW 0x0
29DA  6E0F     MOVWF i, ACCESS
14:                while ((c = *(s + i))) {
29DC  D00B     BRA 0x29F4
29F4  500F     MOVF i, W, ACCESS
15:            	fputc(c,fp);
29DE  C00E     MOVFF c, __pcstackCOMRAM
29E0  F001     NOP
29E2  6A02     CLRF 0x2, ACCESS
29E4  C00C     MOVFF fp, fp
29E6  F003     NOP
29E8  C00D     MOVFF 0xD, data
29EA  F004     NOP
29EC  EC5C     CALL 0x26B8, 0
29EE  F013     NOP
16:                    ++i;
29F0  4A0F     INFSNZ i, F, ACCESS
29F2  2A10     INCF 0x10, F, ACCESS
29F4  500F     MOVF i, W, ACCESS
29F6  240A     ADDWF s, W, ACCESS
29F8  6ED9     MOVWF FSR2, ACCESS
29FA  5010     MOVF 0x10, W, ACCESS
29FC  200B     ADDWFC csize, W, ACCESS
29FE  6EDA     MOVWF FSR2H, ACCESS
2A00  50DF     MOVF INDF2, W, ACCESS
2A02  6E0E     MOVWF c, ACCESS
2A04  500E     MOVF c, W, ACCESS
2A06  B4D8     BTFSC STATUS, 2, ACCESS
2A08  0012     RETURN 0
2A0A  D7E9     BRA 0x29DE
17:                }
18:                return i;
19:            }
20:            
21:            #endif
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/nf_fputc.c  ----------------------
1:             #include <stdio.h>
2:             
3:             #include "stdio_impl.h"
4:             
5:             #ifdef STDIO_NO_FILE_IO
6:             /* "No file system" fputc */
7:             
8:             int fputc(int c, FILE *fp)
9:             {
10:                extern void putch(char);
11:            
12:                if ((fp == stdout) || (fp == stderr)) {
26B8  5003     MOVF fp, W, ACCESS
26BA  1004     IORWF data, W, ACCESS
26BC  B4D8     BTFSC STATUS, 2, ACCESS
26BE  D004     BRA 0x26C8
26C0  5003     MOVF fp, W, ACCESS
26C2  1004     IORWF data, W, ACCESS
26C4  A4D8     BTFSS STATUS, 2, ACCESS
26C6  D004     BRA 0x26D0
13:                    putch(c);
26C8  5001     MOVF __pcstackCOMRAM, W, ACCESS
26CA  ECE3     CALL 0x2BC6, 0
26CC  F015     NOP
14:                } else {
26CE  0012     RETURN 0
15:            	if((fp->limit == 0) || (fp->count < fp->limit)) {
26D0  EE20     LFSR 2, 0x4
26D2  F004     NOP
26D4  5003     MOVF fp, W, ACCESS
26D6  26D9     ADDWF FSR2, F, ACCESS
26D8  5004     MOVF data, W, ACCESS
26DA  22DA     ADDWFC FSR2H, F, ACCESS
26DC  50DE     MOVF POSTINC2, W, ACCESS
26DE  10DE     IORWF POSTINC2, W, ACCESS
26E0  B4D8     BTFSC STATUS, 2, ACCESS
26E2  D016     BRA 0x2710
26E4  EE20     LFSR 2, 0x4
26E6  F004     NOP
26E8  5003     MOVF fp, W, ACCESS
26EA  26D9     ADDWF FSR2, F, ACCESS
26EC  5004     MOVF data, W, ACCESS
26EE  22DA     ADDWFC FSR2H, F, ACCESS
26F0  EE10     LFSR 1, 0x2
26F2  F002     NOP
26F4  5003     MOVF fp, W, ACCESS
26F6  26E1     ADDWF FSR1, F, ACCESS
26F8  5004     MOVF data, W, ACCESS
26FA  22E2     ADDWFC FSR1H, F, ACCESS
26FC  50DE     MOVF POSTINC2, W, ACCESS
26FE  5CE6     SUBWF POSTINC1, W, ACCESS
2700  50E6     MOVF POSTINC1, W, ACCESS
2702  0A80     XORLW 0x80
2704  6E09     MOVWF divisor, ACCESS
2706  50DE     MOVF POSTINC2, W, ACCESS
2708  0A80     XORLW 0x80
270A  5809     SUBWFB divisor, W, ACCESS
270C  B0D8     BTFSC STATUS, 0, ACCESS
270E  0012     RETURN 0
16:            	        fp->buffer[fp->count] = (char)c;
2710  EE20     LFSR 2, 0x2
2712  F002     NOP
2714  5003     MOVF fp, W, ACCESS
2716  26D9     ADDWF FSR2, F, ACCESS
2718  5004     MOVF data, W, ACCESS
271A  22DA     ADDWFC FSR2H, F, ACCESS
271C  CFDE     MOVFF POSTINC2, product
271E  F005     NOP
2720  CFDD     MOVFF POSTDEC2, 0x6
2722  F006     NOP
2724  C003     MOVFF fp, FSR2
2726  FFD9     NOP
2728  C004     MOVFF data, FSR2H
272A  FFDA     NOP
272C  CFDE     MOVFF POSTINC2, c
272E  F007     NOP
2730  CFDD     MOVFF POSTDEC2, s
2732  F008     NOP
2734  5005     MOVF product, W, ACCESS
2736  2407     ADDWF c, W, ACCESS
2738  6ED9     MOVWF FSR2, ACCESS
273A  5006     MOVF 0x6, W, ACCESS
273C  2008     ADDWFC s, W, ACCESS
273E  6EDA     MOVWF FSR2H, ACCESS
2740  C001     MOVFF __pcstackCOMRAM, INDF2
2742  FFDF     NOP
17:            		++fp->count;
2744  EE20     LFSR 2, 0x2
2746  F002     NOP
2748  5003     MOVF fp, W, ACCESS
274A  26D9     ADDWF FSR2, F, ACCESS
274C  5004     MOVF data, W, ACCESS
274E  22DA     ADDWFC FSR2H, F, ACCESS
2750  2ADE     INCF POSTINC2, F, ACCESS
2752  0E00     MOVLW 0x0
2754  22DD     ADDWFC POSTDEC2, F, ACCESS
18:            	}
19:                }
20:                return (unsigned char)c;
21:            }
2756  0012     RETURN 0
22:            
23:            #endif
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/lomod.c  -------------------------
1:             // long long unsigned unsigned modulus
2:             
3:             #pragma warning disable 1516
4:             
5:             unsigned long long int
6:             #ifdef __PICC__
7:             __lomod(unsigned long long int divisor, unsigned long long int dividend)
8:             #else
9:             __lomod(unsigned long long int dividend, unsigned long long int divisor)
10:            #endif
11:            {
12:            	unsigned char	counter;
13:            
14:            	if(divisor != 0) {
24B8  5009     MOVF divisor, W, ACCESS
24BA  100A     IORWF s, W, ACCESS
24BC  100B     IORWF csize, W, ACCESS
24BE  100C     IORWF fp, W, ACCESS
24C0  100D     IORWF 0xD, W, ACCESS
24C2  100E     IORWF c, W, ACCESS
24C4  100F     IORWF i, W, ACCESS
24C6  1010     IORWF 0x10, W, ACCESS
24C8  B4D8     BTFSC STATUS, 2, ACCESS
24CA  D03C     BRA 0x2544
15:            		counter = 1;
24CC  0E01     MOVLW 0x1
24CE  6E11     MOVWF counter, ACCESS
16:            		while((divisor & 0x8000000000000000ULL) == 0) {
24D0  D00A     BRA 0x24E6
24E6  AE10     BTFSS 0x10, 7, ACCESS
24E8  D7F4     BRA 0x24D2
17:            			divisor <<= 1;
24D2  90D8     BCF STATUS, 0, ACCESS
24D4  3609     RLCF divisor, F, ACCESS
24D6  360A     RLCF s, F, ACCESS
24D8  360B     RLCF csize, F, ACCESS
24DA  360C     RLCF fp, F, ACCESS
24DC  360D     RLCF 0xD, F, ACCESS
24DE  360E     RLCF c, F, ACCESS
24E0  360F     RLCF i, F, ACCESS
24E2  3610     RLCF 0x10, F, ACCESS
18:            			counter++;
24E4  2A11     INCF counter, F, ACCESS
19:            		}
20:            		do {
21:            			if((unsigned long long)divisor <= (unsigned long long)dividend)
24EA  5009     MOVF divisor, W, ACCESS
24EC  5C01     SUBWF __pcstackCOMRAM, W, ACCESS
24EE  500A     MOVF s, W, ACCESS
24F0  5802     SUBWFB 0x2, W, ACCESS
24F2  500B     MOVF csize, W, ACCESS
24F4  5803     SUBWFB fp, W, ACCESS
24F6  500C     MOVF fp, W, ACCESS
24F8  5804     SUBWFB data, W, ACCESS
24FA  500D     MOVF 0xD, W, ACCESS
24FC  5805     SUBWFB product, W, ACCESS
24FE  500E     MOVF c, W, ACCESS
2500  5806     SUBWFB 0x6, W, ACCESS
2502  500F     MOVF i, W, ACCESS
2504  5807     SUBWFB c, W, ACCESS
2506  5010     MOVF 0x10, W, ACCESS
2508  5808     SUBWFB s, W, ACCESS
250A  A0D8     BTFSS STATUS, 0, ACCESS
250C  D010     BRA 0x252E
22:            				dividend -= divisor;
250E  5009     MOVF divisor, W, ACCESS
2510  5E01     SUBWF __pcstackCOMRAM, F, ACCESS
2512  500A     MOVF s, W, ACCESS
2514  5A02     SUBWFB 0x2, F, ACCESS
2516  500B     MOVF csize, W, ACCESS
2518  5A03     SUBWFB fp, F, ACCESS
251A  500C     MOVF fp, W, ACCESS
251C  5A04     SUBWFB data, F, ACCESS
251E  500D     MOVF 0xD, W, ACCESS
2520  5A05     SUBWFB product, F, ACCESS
2522  500E     MOVF c, W, ACCESS
2524  5A06     SUBWFB 0x6, F, ACCESS
2526  500F     MOVF i, W, ACCESS
2528  5A07     SUBWFB c, F, ACCESS
252A  5010     MOVF 0x10, W, ACCESS
252C  5A08     SUBWFB s, F, ACCESS
23:            			*(unsigned long long int *)&divisor >>= 1;
252E  90D8     BCF STATUS, 0, ACCESS
2530  3210     RRCF 0x10, F, ACCESS
2532  320F     RRCF i, F, ACCESS
2534  320E     RRCF c, F, ACCESS
2536  320D     RRCF 0xD, F, ACCESS
2538  320C     RRCF fp, F, ACCESS
253A  320B     RRCF csize, F, ACCESS
253C  320A     RRCF s, F, ACCESS
253E  3209     RRCF divisor, F, ACCESS
24:            		} while(--counter != 0);
2540  2E11     DECFSZ counter, F, ACCESS
2542  D7D3     BRA 0x24EA
25:            	}
26:            	return dividend;
2544  C001     MOVFF __pcstackCOMRAM, __pcstackCOMRAM
2546  F001     NOP
2548  C002     MOVFF 0x2, 0x2
254A  F002     NOP
254C  C003     MOVFF fp, fp
254E  F003     NOP
2550  C004     MOVFF data, data
2552  F004     NOP
2554  C005     MOVFF product, product
2556  F005     NOP
2558  C006     MOVFF 0x6, 0x6
255A  F006     NOP
255C  C007     MOVFF c, c
255E  F007     NOP
2560  C008     MOVFF s, s
2562  F008     NOP
27:            }
2564  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/lodiv.c  -------------------------
1:             // long long unsigned unsigned division
2:             
3:             #pragma warning disable 1516
4:             
5:             unsigned long long int
6:             #ifdef __PICC__
7:             __lodiv(unsigned long long int divisor, unsigned long long int dividend)
8:             #else
9:             __lodiv(unsigned long long int dividend, unsigned long long int divisor)
10:            #endif
11:            {
12:            	unsigned long long int	quotient;
13:            	unsigned char	counter;
14:            
15:            	quotient = 0;
23EA  EE20     LFSR 2, 0x11
23EC  F011     NOP
23EE  0E07     MOVLW 0x7
23F0  6ADE     CLRF POSTINC2, ACCESS
23F2  06E8     DECF WREG, F, ACCESS
23F4  E2FD     BC 0x23F0
16:            	if(divisor != 0) {
23F6  5009     MOVF divisor, W, ACCESS
23F8  100A     IORWF s, W, ACCESS
23FA  100B     IORWF csize, W, ACCESS
23FC  100C     IORWF fp, W, ACCESS
23FE  100D     IORWF 0xD, W, ACCESS
2400  100E     IORWF c, W, ACCESS
2402  100F     IORWF i, W, ACCESS
2404  1010     IORWF 0x10, W, ACCESS
2406  B4D8     BTFSC STATUS, 2, ACCESS
2408  D046     BRA 0x2496
17:            		counter = 1;
240A  0E01     MOVLW 0x1
240C  6E19     MOVWF counter, ACCESS
18:            		while((divisor & 0x8000000000000000ULL) == 0) {
240E  D00A     BRA 0x2424
2424  AE10     BTFSS 0x10, 7, ACCESS
2426  D7F4     BRA 0x2410
19:            			divisor <<= 1;
2410  90D8     BCF STATUS, 0, ACCESS
2412  3609     RLCF divisor, F, ACCESS
2414  360A     RLCF s, F, ACCESS
2416  360B     RLCF csize, F, ACCESS
2418  360C     RLCF fp, F, ACCESS
241A  360D     RLCF 0xD, F, ACCESS
241C  360E     RLCF c, F, ACCESS
241E  360F     RLCF i, F, ACCESS
2420  3610     RLCF 0x10, F, ACCESS
20:            			counter++;
2422  2A19     INCF counter, F, ACCESS
21:            		}
22:            		do {
23:            			quotient <<= 1;
2428  90D8     BCF STATUS, 0, ACCESS
242A  3611     RLCF counter, F, ACCESS
242C  3612     RLCF sign, F, ACCESS
242E  3613     RLCF quotient, F, ACCESS
2430  3614     RLCF 0x14, F, ACCESS
2432  3615     RLCF p, F, ACCESS
2434  3616     RLCF i, F, ACCESS
2436  3617     RLCF 0x17, F, ACCESS
2438  3618     RLCF w, F, ACCESS
24:            			if(divisor <= dividend) {
243A  5009     MOVF divisor, W, ACCESS
243C  5C01     SUBWF __pcstackCOMRAM, W, ACCESS
243E  500A     MOVF s, W, ACCESS
2440  5802     SUBWFB 0x2, W, ACCESS
2442  500B     MOVF csize, W, ACCESS
2444  5803     SUBWFB fp, W, ACCESS
2446  500C     MOVF fp, W, ACCESS
2448  5804     SUBWFB data, W, ACCESS
244A  500D     MOVF 0xD, W, ACCESS
244C  5805     SUBWFB product, W, ACCESS
244E  500E     MOVF c, W, ACCESS
2450  5806     SUBWFB 0x6, W, ACCESS
2452  500F     MOVF i, W, ACCESS
2454  5807     SUBWFB c, W, ACCESS
2456  5010     MOVF 0x10, W, ACCESS
2458  5808     SUBWFB s, W, ACCESS
245A  A0D8     BTFSS STATUS, 0, ACCESS
245C  D011     BRA 0x2480
25:            				dividend -= divisor;
245E  5009     MOVF divisor, W, ACCESS
2460  5E01     SUBWF __pcstackCOMRAM, F, ACCESS
2462  500A     MOVF s, W, ACCESS
2464  5A02     SUBWFB 0x2, F, ACCESS
2466  500B     MOVF csize, W, ACCESS
2468  5A03     SUBWFB fp, F, ACCESS
246A  500C     MOVF fp, W, ACCESS
246C  5A04     SUBWFB data, F, ACCESS
246E  500D     MOVF 0xD, W, ACCESS
2470  5A05     SUBWFB product, F, ACCESS
2472  500E     MOVF c, W, ACCESS
2474  5A06     SUBWFB 0x6, F, ACCESS
2476  500F     MOVF i, W, ACCESS
2478  5A07     SUBWFB c, F, ACCESS
247A  5010     MOVF 0x10, W, ACCESS
247C  5A08     SUBWFB s, F, ACCESS
26:            				quotient |= 1;
247E  8011     BSF counter, 0, ACCESS
27:            			}
28:            			divisor >>= 1;
2480  90D8     BCF STATUS, 0, ACCESS
2482  3210     RRCF 0x10, F, ACCESS
2484  320F     RRCF i, F, ACCESS
2486  320E     RRCF c, F, ACCESS
2488  320D     RRCF 0xD, F, ACCESS
248A  320C     RRCF fp, F, ACCESS
248C  320B     RRCF csize, F, ACCESS
248E  320A     RRCF s, F, ACCESS
2490  3209     RRCF divisor, F, ACCESS
29:            		} while(--counter != 0);
2492  2E19     DECFSZ counter, F, ACCESS
2494  D7C9     BRA 0x2428
30:            	}
31:            	return quotient;
2496  C011     MOVFF counter, __pcstackCOMRAM
2498  F001     NOP
249A  C012     MOVFF sign, 0x2
249C  F002     NOP
249E  C013     MOVFF quotient, fp
24A0  F003     NOP
24A2  C014     MOVFF 0x14, data
24A4  F004     NOP
24A6  C015     MOVFF p, product
24A8  F005     NOP
24AA  C016     MOVFF i, 0x6
24AC  F006     NOP
24AE  C017     MOVFF 0x17, c
24B0  F007     NOP
24B2  C018     MOVFF w, s
24B4  F008     NOP
32:            }
24B6  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/isupper.c  -----------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isupper
4:             
5:             int isupper(int c)
6:             {
7:             	return (unsigned)c-'A' < 26;
2AD2  0EBF     MOVLW 0xBF
2AD4  6E03     MOVWF fp, ACCESS
2AD6  0EFF     MOVLW 0xFF
2AD8  6E04     MOVWF data, ACCESS
2ADA  C001     MOVFF __pcstackCOMRAM, product
2ADC  F005     NOP
2ADE  C002     MOVFF 0x2, 0x6
2AE0  F006     NOP
2AE2  5003     MOVF fp, W, ACCESS
2AE4  2605     ADDWF product, F, ACCESS
2AE6  5004     MOVF data, W, ACCESS
2AE8  2206     ADDWFC 0x6, F, ACCESS
2AEA  5006     MOVF 0x6, W, ACCESS
2AEC  E106     BNZ 0x2AFA
2AEE  0E1A     MOVLW 0x1A
2AF0  5C05     SUBWF product, W, ACCESS
2AF2  B0D8     BTFSC STATUS, 0, ACCESS
2AF4  D002     BRA 0x2AFA
2AF6  0E01     MOVLW 0x1
2AF8  D001     BRA 0x2AFC
2AFA  0E00     MOVLW 0x0
2AFC  6E01     MOVWF __pcstackCOMRAM, ACCESS
2AFE  6A02     CLRF 0x2, ACCESS
8:             }
2B00  0012     RETURN 0
9:             
10:            int __isupper_l(int c, locale_t l)
11:            {
12:            	return isupper(c);
13:            }
14:            
15:            weak_alias(__isupper_l, isupper_l);
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/isspace.c  -----------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isspace
4:             
5:             int isspace(int c)
6:             {
7:             	return c == ' ' || (unsigned)c-'\t' < 5;
295E  0E01     MOVLW 0x1
2960  6E07     MOVWF c, ACCESS
2962  0E20     MOVLW 0x20
2964  1801     XORWF __pcstackCOMRAM, W, ACCESS
2966  1002     IORWF 0x2, W, ACCESS
2968  B4D8     BTFSC STATUS, 2, ACCESS
296A  D014     BRA 0x2994
296C  0EF7     MOVLW 0xF7
296E  6E03     MOVWF fp, ACCESS
2970  0EFF     MOVLW 0xFF
2972  6E04     MOVWF data, ACCESS
2974  C001     MOVFF __pcstackCOMRAM, product
2976  F005     NOP
2978  C002     MOVFF 0x2, 0x6
297A  F006     NOP
297C  5003     MOVF fp, W, ACCESS
297E  2605     ADDWF product, F, ACCESS
2980  5004     MOVF data, W, ACCESS
2982  2206     ADDWFC 0x6, F, ACCESS
2984  5006     MOVF 0x6, W, ACCESS
2986  E104     BNZ 0x2990
2988  0E05     MOVLW 0x5
298A  5C05     SUBWF product, W, ACCESS
298C  A0D8     BTFSS STATUS, 0, ACCESS
298E  D002     BRA 0x2994
2990  0E00     MOVLW 0x0
2992  6E07     MOVWF c, ACCESS
2994  C007     MOVFF c, __pcstackCOMRAM
2996  F001     NOP
2998  6A02     CLRF 0x2, ACCESS
8:             }
299A  0012     RETURN 0
9:             
10:            int __isspace_l(int c, locale_t l)
11:            {
12:            	return isspace(c);
13:            }
14:            
15:            weak_alias(__isspace_l, isspace_l);
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/islower.c  -----------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef islower
4:             
5:             int islower(int c)
6:             {
7:             	return (unsigned)c-'a' < 26;
2AA2  0E9F     MOVLW 0x9F
2AA4  6E03     MOVWF fp, ACCESS
2AA6  0EFF     MOVLW 0xFF
2AA8  6E04     MOVWF data, ACCESS
2AAA  C001     MOVFF __pcstackCOMRAM, product
2AAC  F005     NOP
2AAE  C002     MOVFF 0x2, 0x6
2AB0  F006     NOP
2AB2  5003     MOVF fp, W, ACCESS
2AB4  2605     ADDWF product, F, ACCESS
2AB6  5004     MOVF data, W, ACCESS
2AB8  2206     ADDWFC 0x6, F, ACCESS
2ABA  5006     MOVF 0x6, W, ACCESS
2ABC  E106     BNZ 0x2ACA
2ABE  0E1A     MOVLW 0x1A
2AC0  5C05     SUBWF product, W, ACCESS
2AC2  B0D8     BTFSC STATUS, 0, ACCESS
2AC4  D002     BRA 0x2ACA
2AC6  0E01     MOVLW 0x1
2AC8  D001     BRA 0x2ACC
2ACA  0E00     MOVLW 0x0
2ACC  6E01     MOVWF __pcstackCOMRAM, ACCESS
2ACE  6A02     CLRF 0x2, ACCESS
8:             }
2AD0  0012     RETURN 0
9:             
10:            int __islower_l(int c, locale_t l)
11:            {
12:            	return islower(c);
13:            }
14:            
15:            weak_alias(__islower_l, islower_l);
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/isdigit.c  -----------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isdigit
4:             
5:             int isdigit(int c)
6:             {
7:             	return (unsigned)c-'0' < 10;
2B02  0ED0     MOVLW 0xD0
2B04  6E03     MOVWF fp, ACCESS
2B06  0EFF     MOVLW 0xFF
2B08  6E04     MOVWF data, ACCESS
2B0A  C001     MOVFF __pcstackCOMRAM, product
2B0C  F005     NOP
2B0E  C002     MOVFF 0x2, 0x6
2B10  F006     NOP
2B12  5003     MOVF fp, W, ACCESS
2B14  2605     ADDWF product, F, ACCESS
2B16  5004     MOVF data, W, ACCESS
2B18  2206     ADDWFC 0x6, F, ACCESS
2B1A  5006     MOVF 0x6, W, ACCESS
2B1C  E106     BNZ 0x2B2A
2B1E  0E0A     MOVLW 0xA
2B20  5C05     SUBWF product, W, ACCESS
2B22  B0D8     BTFSC STATUS, 0, ACCESS
2B24  D002     BRA 0x2B2A
2B26  0E01     MOVLW 0x1
2B28  D001     BRA 0x2B2C
2B2A  0E00     MOVLW 0x0
2B2C  6E01     MOVWF __pcstackCOMRAM, ACCESS
2B2E  6A02     CLRF 0x2, ACCESS
8:             }
2B30  0012     RETURN 0
9:             
10:            int __isdigit_l(int c, locale_t l)
11:            {
12:            	return isdigit(c);
13:            }
14:            
15:            weak_alias(__isdigit_l, isdigit_l);
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/isalpha.c  -----------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isalpha
4:             
5:             int isalpha(int c)
6:             {
7:             	return ((unsigned)c|32)-'a' < 26;
2A0C  0E9F     MOVLW 0x9F
2A0E  6E03     MOVWF fp, ACCESS
2A10  0EFF     MOVLW 0xFF
2A12  6E04     MOVWF data, ACCESS
2A14  0E20     MOVLW 0x20
2A16  1001     IORWF __pcstackCOMRAM, W, ACCESS
2A18  6E05     MOVWF product, ACCESS
2A1A  0E00     MOVLW 0x0
2A1C  1002     IORWF 0x2, W, ACCESS
2A1E  6E06     MOVWF 0x6, ACCESS
2A20  5003     MOVF fp, W, ACCESS
2A22  2605     ADDWF product, F, ACCESS
2A24  5004     MOVF data, W, ACCESS
2A26  2206     ADDWFC 0x6, F, ACCESS
2A28  5006     MOVF 0x6, W, ACCESS
2A2A  E106     BNZ 0x2A38
2A2C  0E1A     MOVLW 0x1A
2A2E  5C05     SUBWF product, W, ACCESS
2A30  B0D8     BTFSC STATUS, 0, ACCESS
2A32  D002     BRA 0x2A38
2A34  0E01     MOVLW 0x1
2A36  D001     BRA 0x2A3A
2A38  0E00     MOVLW 0x0
2A3A  6E01     MOVWF __pcstackCOMRAM, ACCESS
2A3C  6A02     CLRF 0x2, ACCESS
8:             }
2A3E  0012     RETURN 0
9:             
10:            int __isalpha_l(int c, locale_t l)
11:            {
12:            	return isalpha(c);
13:            }
14:            
15:            weak_alias(__isalpha_l, isalpha_l);
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/doprnt.c  ------------------------
1:             /* vfprintf with configurable support for format conversions */
2:             /* This code is specifically for XC8 */
3:             #include <ctype.h>
4:             #include <math.h>
5:             #include <stdarg.h>
6:             #include <stddef.h>
7:             #include <stdint.h>
8:             #include <stdio.h>
9:             #include <stdlib.h>
10:            #include <string.h>
11:            #include <inline.h>
12:            
13:            /* Configuration options */
14:            #ifdef _VFPF_ALL
15:            #define _VFPF_CONVERT
16:            #define _VFPF_FLAGS
17:            #define _VFPF_WIDTH
18:            #define _VFPF_PRECISION
19:            
20:            #define _VFPF_HH
21:            #define _VFPF_H
22:            #define _VFPF_L
23:            #define _VFPF_LL
24:            #define _VFPF_J
25:            #define _VFPF_T
26:            #define _VFPF_Z
27:            
28:            #define _VFPF_A
29:            #define _VFPF_C
30:            #define _VFPF_D
31:            #define _VFPF_E
32:            #define _VFPF_F
33:            #define _VFPF_G
34:            #define _VFPF_O
35:            #define _VFPF_N
36:            #define _VFPF_P
37:            #define _VFPF_S
38:            #define _VFPF_U
39:            #define _VFPF_X
40:            #endif
41:            
42:            #ifndef ARRAYSIZE
43:            #define ARRAYSIZE(a)	(sizeof(a)/sizeof(a[0]))
44:            #endif
45:            #ifndef CSTRLEN
46:            #define CSTRLEN(s)	(ARRAYSIZE(s)-1)
47:            #endif
48:            
49:            /* Flags, precision, width */
50:            #define MINUS_FLAG (1 << 0)
51:            #define ZERO_FLAG (1 << 1)
52:            #define PLUS_FLAG (1 << 2)
53:            #define SPACE_FLAG (1 << 3)
54:            #define POUND_FLAG (1 << 4)
55:            static int flags, prec, width;
56:            
57:            #ifdef _VFPF_CONVERT
58:            /* This buffer must be at least 32 bytes long for this code to be safe */
59:            /* Output that would exceed buffer capacity is truncated */
60:            #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
61:            #define DBLEN 80
62:            #define EXPLEN 5
63:            #else
64:            #define DBLEN 32
65:            #endif
66:            static char dbuf[DBLEN];
67:            
68:            /* Character count */
69:            static int nout;
70:            
71:            /* Output the string in dbuf, padded on the left or right */
72:            static _INLINE int pad(FILE *fp, char *buf, int p)
73:            {
74:                int i, w;
75:            
76:                /* Left justify ? Put out string */
77:                if (flags & MINUS_FLAG) {
2758  A05D     BTFSS flags, 0, ACCESS
78:                    fputs((const char *)buf, fp);
275C  C013     MOVFF quotient, s
275E  F00A     NOP
2760  C014     MOVFF 0x14, csize
2762  F00B     NOP
2764  C011     MOVFF counter, fp
2766  F00C     NOP
2768  C012     MOVFF sign, 0xD
276A  F00D     NOP
276C  ECEA     CALL 0x29D4, 0
276E  F014     NOP
79:                }
80:            
81:                /* Put out padding */
82:                w = (p < 0) ? 0 : p;
2770  BE16     BTFSC i, 7, ACCESS
2772  D005     BRA 0x277E
2774  C015     MOVFF p, cp
2776  F01A     NOP
2778  C016     MOVFF i, 0x1B
277A  F01B     NOP
277C  D004     BRA 0x2786
277E  0E00     MOVLW 0x0
2780  6E1B     MOVWF 0x1B, ACCESS
2782  0E00     MOVLW 0x0
2784  6E1A     MOVWF cp, ACCESS
83:                i = 0;
2786  0E00     MOVLW 0x0
2788  6E19     MOVWF counter, ACCESS
278A  0E00     MOVLW 0x0
278C  6E18     MOVWF w, ACCESS
84:                while (i < w) {
278E  D00C     BRA 0x27A8
27A8  501A     MOVF cp, W, ACCESS
27AA  5C18     SUBWF w, W, ACCESS
27AC  5019     MOVF counter, W, ACCESS
27AE  0A80     XORLW 0x80
27B0  6E17     MOVWF 0x17, ACCESS
27B2  501B     MOVF 0x1B, W, ACCESS
27B4  0A80     XORLW 0x80
27B6  5817     SUBWFB 0x17, W, ACCESS
27B8  A0D8     BTFSS STATUS, 0, ACCESS
27BA  D7EA     BRA 0x2790
85:                    fputc(' ', fp);
2790  0E00     MOVLW 0x0
2792  6E02     MOVWF 0x2, ACCESS
2794  0E20     MOVLW 0x20
2796  6E01     MOVWF __pcstackCOMRAM, ACCESS
2798  C011     MOVFF counter, fp
279A  F003     NOP
279C  C012     MOVFF sign, data
279E  F004     NOP
27A0  EC5C     CALL 0x26B8, 0
27A2  F013     NOP
86:                    ++i;
27A4  4A18     INFSNZ w, F, ACCESS
27A6  2A19     INCF counter, F, ACCESS
87:                }
88:            
89:                /* Right justify ? Put out string */
90:                if (!(flags & MINUS_FLAG)) {
27BC  B05D     BTFSC flags, 0, ACCESS
27BE  D00A     BRA 0x27D4
91:                    fputs((const char *)buf, fp);
27C0  C013     MOVFF quotient, s
27C2  F00A     NOP
27C4  C014     MOVFF 0x14, csize
27C6  F00B     NOP
27C8  C011     MOVFF counter, fp
27CA  F00C     NOP
27CC  C012     MOVFF sign, 0xD
27CE  F00D     NOP
27D0  ECEA     CALL 0x29D4, 0
27D2  F014     NOP
92:                }
93:            
94:                return strlen(buf) + w;
27D4  C013     MOVFF quotient, __pcstackCOMRAM
27D6  F001     NOP
27D8  C014     MOVFF 0x14, 0x2
27DA  F002     NOP
27DC  EC99     CALL 0x2B32, 0
27DE  F015     NOP
27E0  501A     MOVF cp, W, ACCESS
27E2  2401     ADDWF __pcstackCOMRAM, W, ACCESS
27E4  6E11     MOVWF counter, ACCESS
27E6  501B     MOVF 0x1B, W, ACCESS
27E8  2002     ADDWFC 0x2, W, ACCESS
27EA  6E12     MOVWF sign, ACCESS
95:            }
27EC  0012     RETURN 0
96:            #endif
97:            
98:            #ifdef _VFPF_A
99:            static _INLINE int atoa(FILE *fp, long double f, char c)
100:           {
101:               char mode, nmode;
102:               int d, e, i, m, n, ne, p, pp, sign, t, w;
103:               long double g, h, l, ou, u;
104:           
105:               /* Record sign, get absolute value */
106:               sign = 0;
107:               g = f;
108:               if (g < 0.0) {
109:                   sign = 1;
110:                   g = -g;
111:               }
112:           
113:               /* Print sign, prefix */
114:               n = 0;
115:               w = width;
116:               if (sign || (flags & PLUS_FLAG)) {
117:                   dbuf[n] = sign ? '-' : '+';
118:                   ++n;
119:                   --w;
120:               }
121:               dbuf[n++] = '0';
122:               dbuf[n++] = isupper((int)c) ? 'X' : 'x';
123:           
124:               /* Catch infinities, NaNs here */
125:               if (isinf(g)) {
126:                   if (isupper((int)c)) {
127:                       strcpy(&dbuf[n], "INF");
128:                   } else {
129:                       strcpy(&dbuf[n], "inf");
130:                   }
131:                   w -= CSTRLEN("inf");
132:                   return pad(fp, &dbuf[0], w);
133:               }
134:               if (isnan(g)) {
135:                   if (isupper((int)c)) {
136:                       strcpy(&dbuf[n], "NAN");
137:                   } else {
138:                       strcpy(&dbuf[n], "nan");
139:                   }
140:                   w -= CSTRLEN("inf");
141:                   return pad(fp, &dbuf[0], w);
142:               }
143:           
144:               /* First find the largest power of 2 not larger than number to print */
145:               u = 1.0;
146:               e = 0;
147:               if (!(g == 0.0)) {
148:                   while (!(g < (u*2.0))) {
149:                       u = u*2.0;
150:                       ++e;
151:                   }
152:                   while (g < u) {
153:                       u = u/2.0;
154:                       --e;
155:                   }
156:               }
157:           
158:               /* Get precision */
159:               p = (prec < 0) ? 6 : prec;
160:           
161:               /* Hex places, total */
162:               m = p + 1;
163:           
164:               /* Go through the conversion once to get to the rounding step */
165:               i = 0;
166:               h = g;
167:               ou = u;
168:               while (i < m) {
169:                   l = floor(h/u);
170:                   d = (int)l;
171:                   h -= l*u;
172:                   u = u/16.0;
173:                   ++i;
174:               }
175:               
176:               /* Remainder >= halfway ? */
177:               l = u*8.0;
178:               if (h < l) {
179:                   l = 0.0;
180:               } else {
181:                   /* On tie choose even number */
182:                   if ((h == l) && !(d % 2)) {
183:                       l = 0.0;
184:                   }
185:               }
186:           
187:               /* Round */
188:               h = g + l;
189:               
190:               /* Convert again, after rounding */
191:               u = ou;
192:               ne = 0;
193:               pp = 0;
194:               t = 0;
195:               i = 0;
196:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
197:                   l = floor(h/u);
198:                   d = (int)l;
199:                   if (!(flags & POUND_FLAG) && !d && (ne < 0)) {
200:                       ++t;
201:                   } else {
202:                       if (!pp && (ne < 0)) {
203:                           dbuf[n++] = '.';
204:                           --w;
205:                           pp = 1;
206:                       }
207:                       while (t) {
208:                           dbuf[n++] = '0';
209:                           --w;
210:                           --t;
211:                       }
212:                       d = (d < 10) ? '0' + d : 'a' + (d - 10);
213:                       if (isupper((int)c) && isalpha(d)) {
214:                           d = toupper(d);
215:                       }
216:                       dbuf[n++] = d;
217:                       --w;
218:                   }
219:                   h -= l*u;
220:                   u = u/16.0;
221:                   --ne;
222:                   ++i;
223:               }
224:               if (!pp && (flags & POUND_FLAG)) {
225:                   dbuf[n++] = '.';
226:               }
227:               dbuf[n] = '\0';
228:           
229:               /* Convert exponent */
230:               i = sizeof(dbuf) - 1;
231:               dbuf[i] = '\0';
232:               sign = 0;
233:               if (e < 0) {
234:                   sign = 1;
235:                   e = -e;
236:               }
237:               p = 1;
238:               while (e || (0 < p)) {
239:                   --i;
240:                   dbuf[i] = '0' + (e % 10);
241:                   e = e / 10;
242:                   --p;
243:                   --w;
244:               }
245:               --i;
246:               dbuf[i] = sign ? '-' : '+';
247:               --w;
248:               --i;
249:               dbuf[i] = isupper((int)c) ? 'P' : 'p';
250:               --w;
251:               strcpy(&dbuf[n], &dbuf[i]);
252:           
253:               /* Put out padded string */
254:               return pad(fp, &dbuf[0], w);
255:           }
256:           #endif
257:           
258:           #ifdef _VFPF_C
259:           static _INLINE int ctoa(FILE *fp, char c)
260:           {
261:               int l, w;
262:           
263:               /* Get width */
264:               w = width ? width - 1 : width;
2844  0100     MOVLB 0x0
265:           
266:               /* Put out padded string */
267:               dbuf[0] = c;
2864  C01E     MOVFF d, dbuf
2866  F0A6     NOP
268:               dbuf[1] = '\0';
2868  0E00     MOVLW 0x0
286A  6FA7     MOVWF 0xA7, BANKED
269:               return pad(fp, &dbuf[0], w);
286C  C01C     MOVFF fp, counter
286E  F011     NOP
2870  C01D     MOVFF 0x1D, sign
2872  F012     NOP
2874  0EA6     MOVLW 0xA6
2876  6E13     MOVWF quotient, ACCESS
2878  0E00     MOVLW 0x0
287A  6E14     MOVWF 0x14, ACCESS
287C  C01F     MOVFF w, p
287E  F015     NOP
2880  C020     MOVFF 0x20, i
2882  F016     NOP
2884  ECAC     CALL 0x2758, 0
2886  F013     NOP
2888  C011     MOVFF counter, fp
288A  F01C     NOP
288C  C012     MOVFF sign, 0x1D
288E  F01D     NOP
270:           }
2890  0012     RETURN 0
271:           #endif
272:           
273:           #ifdef _VFPF_D
274:           static _INLINE int dtoa(FILE *fp, long long d)
275:           {
276:               int i, p, s, w;
277:               long long n;
278:           
279:               /* Record sign, get absolute value */
280:               n = d;
15C0  C01E     MOVFF d, n
281:               s = n < 0 ? 1 : 0;
15E0  AE3D     BTFSS 0x3D, 7, ACCESS
15E2  D002     BRA 0x15E8
15E4  0E01     MOVLW 0x1
15E6  D001     BRA 0x15EA
15E8  0E00     MOVLW 0x0
15EA  6E34     MOVWF n, ACCESS
15EC  6A35     CLRF w, ACCESS
282:               if (s) {
15EE  5034     MOVF n, W, ACCESS
15F0  1035     IORWF w, W, ACCESS
15F2  B4D8     BTFSC STATUS, 2, ACCESS
15F4  D010     BRA 0x1616
283:                   n = -n;
15F6  1E3D     COMF 0x3D, F, ACCESS
15F8  1E3C     COMF i, F, ACCESS
15FA  1E3B     COMF 0x3B, F, ACCESS
15FC  1E3A     COMF i, F, ACCESS
15FE  1E39     COMF 0x39, F, ACCESS
1600  1E38     COMF 0x38, F, ACCESS
1602  1E37     COMF n, F, ACCESS
1604  6C36     NEGF n, ACCESS
1606  0E00     MOVLW 0x0
1608  2237     ADDWFC n, F, ACCESS
160A  2238     ADDWFC 0x38, F, ACCESS
160C  2239     ADDWFC 0x39, F, ACCESS
160E  223A     ADDWFC i, F, ACCESS
1610  223B     ADDWFC 0x3B, F, ACCESS
1612  223C     ADDWFC i, F, ACCESS
1614  223D     ADDWFC 0x3D, F, ACCESS
284:               }
285:           
286:               /* Adjust flags, precision, width */
287:               if (!(prec < 0)) {
1616  0100     MOVLB 0x0
1618  AFA5     BTFSS 0xA5, 7, BANKED
288:                   flags &= ~ZERO_FLAG;
161A  925D     BCF flags, 1, ACCESS
289:               }
290:               p = (0 < prec) ? prec : 1;
161C  BFA5     BTFSC 0xA5, 7, BANKED
161E  D005     BRA 0x162A
1620  51A5     MOVF 0xA5, W, BANKED
1622  E108     BNZ 0x1634
1624  05A4     DECF prec, W, BANKED
1626  B0D8     BTFSC STATUS, 0, ACCESS
1628  D005     BRA 0x1634
162A  0E00     MOVLW 0x0
162C  6E31     MOVWF 0x31, ACCESS
162E  0E01     MOVLW 0x1
1630  6E30     MOVWF w, ACCESS
1632  D004     BRA 0x163C
1634  C0A4     MOVFF prec, w
1636  F030     NOP
1638  C0A5     MOVFF 0xA5, 0x31
163A  F031     NOP
291:               w = width;
163C  C0A2     MOVFF width, n
163E  F032     NOP
1640  C0A3     MOVFF 0xA3, p
1642  F033     NOP
292:               if (s || (flags & PLUS_FLAG)) {
1644  5034     MOVF n, W, ACCESS
1646  1035     IORWF w, W, ACCESS
1648  A4D8     BTFSS STATUS, 2, ACCESS
164A  D002     BRA 0x1650
164C  A45D     BTFSS flags, 2, ACCESS
164E  D003     BRA 0x1656
293:                   --w;
1650  0632     DECF n, F, ACCESS
1652  A0D8     BTFSS STATUS, 0, ACCESS
1654  0633     DECF p, F, ACCESS
294:               }
295:           
296:               /* Convert to decimal, possibly filling on the left with zeroes */
297:               i = sizeof(dbuf) - 1;
1656  0E00     MOVLW 0x0
1658  6E3F     MOVWF i, ACCESS
165A  0E1F     MOVLW 0x1F
165C  6E3E     MOVWF i, ACCESS
298:               dbuf[i] = '\0';
165E  0E00     MOVLW 0x0
1660  6FC5     MOVWF 0xC5, BANKED
299:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
1662  D07C     BRA 0x175C
175C  BE3F     BTFSC i, 7, ACCESS
175E  D01F     BRA 0x179E
1760  503F     MOVF i, W, ACCESS
1762  E103     BNZ 0x176A
1764  043E     DECF i, W, ACCESS
1766  A0D8     BTFSS STATUS, 0, ACCESS
1768  D01A     BRA 0x179E
176A  5036     MOVF n, W, ACCESS
176C  1037     IORWF n, W, ACCESS
176E  1038     IORWF 0x38, W, ACCESS
1770  1039     IORWF 0x39, W, ACCESS
1772  103A     IORWF i, W, ACCESS
1774  103B     IORWF 0x3B, W, ACCESS
1776  103C     IORWF i, W, ACCESS
1778  103D     IORWF 0x3D, W, ACCESS
177A  A4D8     BTFSS STATUS, 2, ACCESS
177C  D773     BRA 0x1664
177E  BE31     BTFSC 0x31, 7, ACCESS
1780  D005     BRA 0x178C
1782  5031     MOVF 0x31, W, ACCESS
1784  E102     BNZ 0x178A
1786  0430     DECF w, W, ACCESS
1788  B0D8     BTFSC STATUS, 0, ACCESS
178A  D76C     BRA 0x1664
178C  BE33     BTFSC p, 7, ACCESS
178E  D007     BRA 0x179E
1790  5033     MOVF p, W, ACCESS
1792  E103     BNZ 0x179A
1794  0432     DECF n, W, ACCESS
1796  A0D8     BTFSS STATUS, 0, ACCESS
1798  D002     BRA 0x179E
179A  B25D     BTFSC flags, 1, ACCESS
179C  D763     BRA 0x1664
300:                   --i;
1664  063E     DECF i, F, ACCESS
1666  A0D8     BTFSS STATUS, 0, ACCESS
1668  063F     DECF i, F, ACCESS
301:                   dbuf[i] = '0' + abs(n % 10);
166A  0EA6     MOVLW 0xA6
166C  243E     ADDWF i, W, ACCESS
166E  6ED9     MOVWF FSR2, ACCESS
1670  0E00     MOVLW 0x0
1672  203F     ADDWFC i, W, ACCESS
1674  6EDA     MOVWF FSR2H, ACCESS
1676  C036     MOVFF n, __pcstackCOMRAM
1678  F001     NOP
167A  C037     MOVFF n, 0x2
167C  F002     NOP
167E  C038     MOVFF 0x38, fp
1680  F003     NOP
1682  C039     MOVFF 0x39, data
1684  F004     NOP
1686  C03A     MOVFF i, product
1688  F005     NOP
168A  C03B     MOVFF 0x3B, 0x6
168C  F006     NOP
168E  C03C     MOVFF i, c
1690  F007     NOP
1692  C03D     MOVFF 0x3D, s
1694  F008     NOP
1696  0E0A     MOVLW 0xA
1698  6E09     MOVWF divisor, ACCESS
169A  0E00     MOVLW 0x0
169C  6E0A     MOVWF s, ACCESS
169E  0E00     MOVLW 0x0
16A0  6E0B     MOVWF csize, ACCESS
16A2  0E00     MOVLW 0x0
16A4  6E0C     MOVWF fp, ACCESS
16A6  0E00     MOVLW 0x0
16A8  6E0D     MOVWF 0xD, ACCESS
16AA  0E00     MOVLW 0x0
16AC  6E0E     MOVWF c, ACCESS
16AE  0E00     MOVLW 0x0
16B0  6E0F     MOVWF i, ACCESS
16B2  0E00     MOVLW 0x0
16B4  6E10     MOVWF 0x10, ACCESS
16B6  EC85     CALL 0x210A, 0
16B8  F010     NOP
16BA  C001     MOVFF __pcstackCOMRAM, x
16BC  F026     NOP
16BE  C002     MOVFF 0x2, 0x27
16C0  F027     NOP
16C2  C003     MOVFF fp, 0x28
16C4  F028     NOP
16C6  C004     MOVFF data, 0x29
16C8  F029     NOP
16CA  C005     MOVFF product, 0x2A
16CC  F02A     NOP
16CE  C006     MOVFF 0x6, 0x2B
16D0  F02B     NOP
16D2  C007     MOVFF c, 0x2C
16D4  F02C     NOP
16D6  C008     MOVFF s, 0x2D
16D8  F02D     NOP
16DA  C026     MOVFF x, quotient
16DC  F013     NOP
16DE  C028     MOVFF 0x28, 0x14
16E0  F014     NOP
16E2  EC20     CALL 0x2A40, 0
16E4  F015     NOP
16E6  5013     MOVF quotient, W, ACCESS
16E8  0F30     ADDLW 0x30
16EA  6EDF     MOVWF INDF2, ACCESS
302:                   --p;
16EC  0630     DECF w, F, ACCESS
16EE  A0D8     BTFSS STATUS, 0, ACCESS
16F0  0631     DECF 0x31, F, ACCESS
303:                   --w;
16F2  0632     DECF n, F, ACCESS
16F4  A0D8     BTFSS STATUS, 0, ACCESS
16F6  0633     DECF p, F, ACCESS
304:                   n = n / 10;
16F8  C036     MOVFF n, __pcstackCOMRAM
16FA  F001     NOP
16FC  C037     MOVFF n, 0x2
16FE  F002     NOP
1700  C038     MOVFF 0x38, fp
1702  F003     NOP
1704  C039     MOVFF 0x39, data
1706  F004     NOP
1708  C03A     MOVFF i, product
170A  F005     NOP
170C  C03B     MOVFF 0x3B, 0x6
170E  F006     NOP
1710  C03C     MOVFF i, c
1712  F007     NOP
1714  C03D     MOVFF 0x3D, s
1716  F008     NOP
1718  0E0A     MOVLW 0xA
171A  6E09     MOVWF divisor, ACCESS
171C  0E00     MOVLW 0x0
171E  6E0A     MOVWF s, ACCESS
1720  0E00     MOVLW 0x0
1722  6E0B     MOVWF csize, ACCESS
1724  0E00     MOVLW 0x0
1726  6E0C     MOVWF fp, ACCESS
1728  0E00     MOVLW 0x0
172A  6E0D     MOVWF 0xD, ACCESS
172C  0E00     MOVLW 0x0
172E  6E0E     MOVWF c, ACCESS
1730  0E00     MOVLW 0x0
1732  6E0F     MOVWF i, ACCESS
1734  0E00     MOVLW 0x0
1736  6E10     MOVWF 0x10, ACCESS
1738  ECAD     CALL 0x1D5A, 0
173A  F00E     NOP
173C  C001     MOVFF __pcstackCOMRAM, n
173E  F036     NOP
1740  C002     MOVFF 0x2, n
1742  F037     NOP
1744  C003     MOVFF fp, 0x38
1746  F038     NOP
1748  C004     MOVFF data, 0x39
174A  F039     NOP
174C  C005     MOVFF product, i
174E  F03A     NOP
1750  C006     MOVFF 0x6, 0x3B
1752  F03B     NOP
1754  C007     MOVFF c, i
1756  F03C     NOP
1758  C008     MOVFF s, 0x3D
175A  F03D     NOP
305:               }
306:           
307:               /* Display sign if required */
308:               if (s || (flags & PLUS_FLAG)) {
179E  5034     MOVF n, W, ACCESS
17A0  1035     IORWF w, W, ACCESS
17A2  A4D8     BTFSS STATUS, 2, ACCESS
17A4  D002     BRA 0x17AA
17A6  A45D     BTFSS flags, 2, ACCESS
17A8  D017     BRA 0x17D8
309:                   --i;
17AA  063E     DECF i, F, ACCESS
17AC  A0D8     BTFSS STATUS, 0, ACCESS
17AE  063F     DECF i, F, ACCESS
310:                   dbuf[i] = s ? '-' : '+';
17B0  5034     MOVF n, W, ACCESS
17B2  1035     IORWF w, W, ACCESS
17B4  A4D8     BTFSS STATUS, 2, ACCESS
17B6  D004     BRA 0x17C0
17B8  0E00     MOVLW 0x0
17BA  6E2F     MOVWF 0x2F, ACCESS
17BC  0E2B     MOVLW 0x2B
17BE  D003     BRA 0x17C6
17C0  0E00     MOVLW 0x0
17C2  6E2F     MOVWF 0x2F, ACCESS
17C4  0E2D     MOVLW 0x2D
17C6  6E2E     MOVWF p, ACCESS
17C8  0EA6     MOVLW 0xA6
17CA  243E     ADDWF i, W, ACCESS
17CC  6ED9     MOVWF FSR2, ACCESS
17CE  0E00     MOVLW 0x0
17D0  203F     ADDWFC i, W, ACCESS
17D2  6EDA     MOVWF FSR2H, ACCESS
17D4  C02E     MOVFF p, INDF2
17D6  FFDF     NOP
311:               }
312:           
313:               /* Put out padded string */
314:               return pad(fp, &dbuf[i], w);
17D8  C01C     MOVFF fp, counter
17DA  F011     NOP
17DC  C01D     MOVFF 0x1D, sign
17DE  F012     NOP
17E0  0EA6     MOVLW 0xA6
17E2  243E     ADDWF i, W, ACCESS
17E4  6E13     MOVWF quotient, ACCESS
17E6  0E00     MOVLW 0x0
17E8  203F     ADDWFC i, W, ACCESS
17EA  6E14     MOVWF 0x14, ACCESS
17EC  C032     MOVFF n, p
17EE  F015     NOP
17F0  C033     MOVFF p, i
17F2  F016     NOP
17F4  ECAC     CALL 0x2758, 0
17F6  F013     NOP
17F8  C011     MOVFF counter, fp
17FA  F01C     NOP
17FC  C012     MOVFF sign, 0x1D
17FE  F01D     NOP
315:           }
1800  0012     RETURN 0
316:           #endif
317:           
318:           #if defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
319:           static _INLINE int efgtoa(FILE *fp, long double f, char c)
320:           {
321:               char mode, nmode;
322:               int d, e, i, m, n, ne, p, pp, sign, t, w;
323:               long double g, h, l, ou, u;
324:           
325:               /* Record sign, get absolute value */
326:               sign = 0;
327:               g = f;
328:               if (g < 0.0) {
329:                   sign = 1;
330:                   g = -g;
331:               }
332:           
333:               /* Print sign */
334:               n = 0;
335:               w = width;
336:               if (sign || (flags & PLUS_FLAG)) {
337:                   dbuf[n] = sign ? '-' : '+';
338:                   ++n;
339:                   --w;
340:               }
341:           
342:               /* Catch infinities, NaNs here */
343:               if (isinf(g)) {
344:                   if (isupper((int)c)) {
345:                       strcpy(&dbuf[n], "INF");
346:                   } else {
347:                       strcpy(&dbuf[n], "inf");
348:                   }
349:                   w -= CSTRLEN("inf");
350:                   return pad(fp, &dbuf[0], w);
351:               }
352:               if (isnan(g)) {
353:                   if (isupper((int)c)) {
354:                       strcpy(&dbuf[n], "NAN");
355:                   } else {
356:                       strcpy(&dbuf[n], "nan");
357:                   }
358:                   w -= CSTRLEN("inf");
359:                   return pad(fp, &dbuf[0], w);
360:               }
361:           
362:               /* First find the largest power of 10 not larger than number to print */
363:               u = 1.0;
364:               e = 0;
365:               if (!(g == 0.0)) {
366:                   while (!(g < (u*10.0))) {
367:                       u = u*10.0;
368:                       ++e;
369:                   }
370:                   while (g < u) {
371:                       u = u/10.0;
372:                       --e;
373:                   }
374:               }
375:           
376:               /* Get mode, precision */
377:               mode = tolower((int)c);
378:               nmode = mode;
379:               if (mode == 'g') {
380:           		if (prec == 0) {
381:           			prec = 1;
382:           		}
383:                   p = (0 < prec) ? prec : 6;
384:               } else {
385:                   p = (prec < 0) ? 6 : prec;
386:               }
387:           
388:               /* Choose e or f mode from g mode */
389:               if (mode == 'g') {
390:                   if (!(e < -4) && !((p - 1) < e)) {
391:                       nmode = 'f';
392:                   } else {
393:                       nmode = 'e';
394:                   }
395:               }
396:           
397:               /* Decimal places or significant digits */
398:               m = p;
399:               if (!(mode == 'g') || ((nmode == 'f') && (e < 0))) {
400:                   ++m;
401:               }
402:           
403:               /* Adjust starting exponent, string length for 'f' conversions */
404:               if (nmode == 'f') {
405:                   if (e < 0) {
406:                       u = 1.0;
407:                       e = 0;
408:                   }
409:                   if (!(mode == 'g')) {
410:                       m += e;
411:                   }
412:               }
413:           
414:               /* Go through the conversion once to get to the rounding step */
415:               i = 0;
416:               h = g;
417:               ou = u;
418:               while (i < m) {
419:                   l = floor(h/u);
420:                   d = (int)l;
421:                   h -= l*u;
422:                   u = u/10.0;
423:                   ++i;
424:               }
425:               
426:               /* Remainder >= halfway ? */
427:               l = u*5.0;
428:               if (h < l) {
429:                   l = 0.0;
430:               } else {
431:                   /* On tie choose even number */
432:                   if ((h == l) && !(d % 2)) {
433:                       l = 0.0;
434:                   }
435:               }
436:           
437:               /* Round */
438:               h = g + l;
439:               
440:               /* Convert again, after rounding */
441:               u = ou;
442:               ne = (nmode == 'e') ? 0 : e;
443:               pp = 0;
444:               t = 0;
445:               i = 0;
446:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
447:                   l = floor(h/u);
448:                   d = (int)l;
449:                   if (!(flags & POUND_FLAG) && !d && (mode == 'g') && (ne < 0)) {
450:                       ++t;
451:                   } else {
452:                       if (!pp && (ne < 0)) {
453:                           dbuf[n++] = '.';
454:                           --w;
455:                           pp = 1;
456:                       }
457:                       while (t) {
458:                           dbuf[n++] = '0';
459:                           --w;
460:                           --t;
461:                       }
462:                       dbuf[n++] = '0' + d;
463:                       --w;
464:                   }
465:                   h -= l*u;
466:                   u = u/10.0;
467:                   --ne;
468:                   ++i;
469:               }
470:               if (!pp && (flags & POUND_FLAG)) {
471:                   dbuf[n++] = '.';
472:               }
473:               dbuf[n] = '\0';
474:           
475:               /* Convert exponent */
476:               if (nmode == 'e') {
477:                   i = sizeof(dbuf) - 1;
478:                   dbuf[i] = '\0';
479:                   sign = 0;
480:                   if (e < 0) {
481:                       sign = 1;
482:                       e = -e;
483:                   }
484:                   p = 2;
485:                   while (e || (0 < p)) {
486:                       --i;
487:                       dbuf[i] = '0' + (e % 10);
488:                       e = e / 10;
489:                       --p;
490:                       --w;
491:                   }
492:                   --i;
493:                   dbuf[i] = sign ? '-' : '+';
494:                   --w;
495:                   --i;
496:                   dbuf[i] = isupper((int)c) ? 'E' : 'e';
497:                   --w;
498:                   strcpy(&dbuf[n], &dbuf[i]);
499:               }
500:           
501:               /* Put out padded string */
502:               return pad(fp, &dbuf[0], w);
503:           }
504:           #endif
505:           
506:           #ifdef _VFPF_O
507:           static _INLINE int otoa(FILE *fp, unsigned long long d)
508:           {
509:               int i, p, t, w;
510:               unsigned long long n;
511:           
512:               /* Adjust flags, precision, width */
513:               if (!(prec < 0)) {
1BDC  0100     MOVLB 0x0
514:                   flags &= ~ZERO_FLAG;
1BE0  925D     BCF flags, 1, ACCESS
515:               }
516:               p = (0 < prec) ? prec : 1;
1BE2  BFA5     BTFSC 0xA5, 7, BANKED
1BE4  D005     BRA 0x1BF0
1BE6  51A5     MOVF 0xA5, W, BANKED
1BE8  E108     BNZ 0x1BFA
1BEA  05A4     DECF prec, W, BANKED
1BEC  B0D8     BTFSC STATUS, 0, ACCESS
1BEE  D005     BRA 0x1BFA
1BF0  0E00     MOVLW 0x0
1BF2  6E2F     MOVWF 0x2F, ACCESS
1BF4  0E01     MOVLW 0x1
1BF6  6E2E     MOVWF p, ACCESS
1BF8  D004     BRA 0x1C02
1BFA  C0A4     MOVFF prec, p
1BFC  F02E     NOP
1BFE  C0A5     MOVFF 0xA5, 0x2F
1C00  F02F     NOP
517:               w = width;
1C02  C0A2     MOVFF width, n
1C04  F032     NOP
1C06  C0A3     MOVFF 0xA3, p
1C08  F033     NOP
518:           
519:               /* Convert to octal, possibly filling on the left with zeroes */
520:               n = d;
1C0A  C01E     MOVFF d, n
1C0C  F034     NOP
1C0E  C01F     MOVFF w, w
1C10  F035     NOP
1C12  C020     MOVFF 0x20, n
1C14  F036     NOP
1C16  C021     MOVFF 0x21, n
1C18  F037     NOP
1C1A  C022     MOVFF 0x22, 0x38
1C1C  F038     NOP
1C1E  C023     MOVFF 0x23, 0x39
1C20  F039     NOP
1C22  C024     MOVFF 0x24, i
1C24  F03A     NOP
1C26  C025     MOVFF 0x25, 0x3B
1C28  F03B     NOP
521:               i = sizeof(dbuf) - 1;
1C2A  0E00     MOVLW 0x0
1C2C  6E3D     MOVWF 0x3D, ACCESS
1C2E  0E1F     MOVLW 0x1F
1C30  6E3C     MOVWF i, ACCESS
522:               dbuf[i] = '\0';
1C32  0E00     MOVLW 0x0
1C34  6FC5     MOVWF 0xC5, BANKED
523:               t = 0;
1C36  0E00     MOVLW 0x0
1C38  6E31     MOVWF 0x31, ACCESS
1C3A  0E00     MOVLW 0x0
1C3C  6E30     MOVWF w, ACCESS
524:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
1C3E  D043     BRA 0x1CC6
1CC6  BE3D     BTFSC 0x3D, 7, ACCESS
1CC8  D01F     BRA 0x1D08
1CCA  503D     MOVF 0x3D, W, ACCESS
1CCC  E103     BNZ 0x1CD4
1CCE  043C     DECF i, W, ACCESS
1CD0  A0D8     BTFSS STATUS, 0, ACCESS
1CD2  D01A     BRA 0x1D08
1CD4  5034     MOVF n, W, ACCESS
1CD6  1035     IORWF w, W, ACCESS
1CD8  1036     IORWF n, W, ACCESS
1CDA  1037     IORWF n, W, ACCESS
1CDC  1038     IORWF 0x38, W, ACCESS
1CDE  1039     IORWF 0x39, W, ACCESS
1CE0  103A     IORWF i, W, ACCESS
1CE2  103B     IORWF 0x3B, W, ACCESS
1CE4  A4D8     BTFSS STATUS, 2, ACCESS
1CE6  D7AC     BRA 0x1C40
1CE8  BE2F     BTFSC 0x2F, 7, ACCESS
1CEA  D005     BRA 0x1CF6
1CEC  502F     MOVF 0x2F, W, ACCESS
1CEE  E1A8     BNZ 0x1C40
1CF0  042E     DECF p, W, ACCESS
1CF2  B0D8     BTFSC STATUS, 0, ACCESS
1CF4  D7A5     BRA 0x1C40
1CF6  BE33     BTFSC p, 7, ACCESS
1CF8  D007     BRA 0x1D08
1CFA  5033     MOVF p, W, ACCESS
1CFC  E103     BNZ 0x1D04
1CFE  0432     DECF n, W, ACCESS
1D00  A0D8     BTFSS STATUS, 0, ACCESS
1D02  D002     BRA 0x1D08
1D04  B25D     BTFSC flags, 1, ACCESS
1D06  D79C     BRA 0x1C40
525:                   --i;
1C40  063C     DECF i, F, ACCESS
1C42  A0D8     BTFSS STATUS, 0, ACCESS
1C44  063D     DECF 0x3D, F, ACCESS
526:                   t = n & 07;
1C46  0E07     MOVLW 0x7
1C48  1434     ANDWF n, W, ACCESS
1C4A  6E30     MOVWF w, ACCESS
1C4C  6A31     CLRF 0x31, ACCESS
527:                   dbuf[i] = '0' + t;
1C4E  0EA6     MOVLW 0xA6
1C50  243C     ADDWF i, W, ACCESS
1C52  6ED9     MOVWF FSR2, ACCESS
1C54  0E00     MOVLW 0x0
1C56  203D     ADDWFC 0x3D, W, ACCESS
1C58  6EDA     MOVWF FSR2H, ACCESS
1C5A  5030     MOVF w, W, ACCESS
1C5C  0F30     ADDLW 0x30
1C5E  6EDF     MOVWF INDF2, ACCESS
528:                   --p;
1C60  062E     DECF p, F, ACCESS
1C62  A0D8     BTFSS STATUS, 0, ACCESS
1C64  062F     DECF 0x2F, F, ACCESS
529:                   --w;
1C66  0632     DECF n, F, ACCESS
1C68  A0D8     BTFSS STATUS, 0, ACCESS
1C6A  0633     DECF p, F, ACCESS
530:                   n = n >> 3;
1C6C  C034     MOVFF n, x
1C6E  F026     NOP
1C70  C035     MOVFF w, 0x27
1C72  F027     NOP
1C74  C036     MOVFF n, 0x28
1C76  F028     NOP
1C78  C037     MOVFF n, 0x29
1C7A  F029     NOP
1C7C  C038     MOVFF 0x38, 0x2A
1C7E  F02A     NOP
1C80  C039     MOVFF 0x39, 0x2B
1C82  F02B     NOP
1C84  C03A     MOVFF i, 0x2C
1C86  F02C     NOP
1C88  C03B     MOVFF 0x3B, 0x2D
1C8A  F02D     NOP
1C8C  0E04     MOVLW 0x4
1C8E  D009     BRA 0x1CA2
1C90  90D8     BCF STATUS, 0, ACCESS
1C92  322D     RRCF 0x2D, F, ACCESS
1C94  322C     RRCF 0x2C, F, ACCESS
1C96  322B     RRCF 0x2B, F, ACCESS
1C98  322A     RRCF 0x2A, F, ACCESS
1C9A  3229     RRCF 0x29, F, ACCESS
1C9C  3228     RRCF 0x28, F, ACCESS
1C9E  3227     RRCF 0x27, F, ACCESS
1CA0  3226     RRCF x, F, ACCESS
1CA2  2EE8     DECFSZ WREG, F, ACCESS
1CA4  D7F5     BRA 0x1C90
1CA6  C026     MOVFF x, n
1CA8  F034     NOP
1CAA  C027     MOVFF 0x27, w
1CAC  F035     NOP
1CAE  C028     MOVFF 0x28, n
1CB0  F036     NOP
1CB2  C029     MOVFF 0x29, n
1CB4  F037     NOP
1CB6  C02A     MOVFF 0x2A, 0x38
1CB8  F038     NOP
1CBA  C02B     MOVFF 0x2B, 0x39
1CBC  F039     NOP
1CBE  C02C     MOVFF 0x2C, i
1CC0  F03A     NOP
1CC2  C02D     MOVFF 0x2D, 0x3B
1CC4  F03B     NOP
531:               }
532:           
533:               /* Display prefix if required */
534:               if ((flags & POUND_FLAG) && t) {
1D08  A85D     BTFSS flags, 4, ACCESS
1D0A  D012     BRA 0x1D30
1D0C  5030     MOVF w, W, ACCESS
1D0E  1031     IORWF 0x31, W, ACCESS
1D10  B4D8     BTFSC STATUS, 2, ACCESS
1D12  D00E     BRA 0x1D30
535:                   --i;
1D14  063C     DECF i, F, ACCESS
1D16  A0D8     BTFSS STATUS, 0, ACCESS
1D18  063D     DECF 0x3D, F, ACCESS
536:                   dbuf[i] = '0';
1D1A  0EA6     MOVLW 0xA6
1D1C  243C     ADDWF i, W, ACCESS
1D1E  6ED9     MOVWF FSR2, ACCESS
1D20  0E00     MOVLW 0x0
1D22  203D     ADDWFC 0x3D, W, ACCESS
1D24  6EDA     MOVWF FSR2H, ACCESS
1D26  0E30     MOVLW 0x30
1D28  6EDF     MOVWF INDF2, ACCESS
537:                   --w;
1D2A  0632     DECF n, F, ACCESS
1D2C  A0D8     BTFSS STATUS, 0, ACCESS
1D2E  0633     DECF p, F, ACCESS
538:               }
539:           
540:               /* Put out padded string */
541:               return pad(fp, &dbuf[i], w);
1D30  C01C     MOVFF fp, counter
1D32  F011     NOP
1D34  C01D     MOVFF 0x1D, sign
1D36  F012     NOP
1D38  0EA6     MOVLW 0xA6
1D3A  243C     ADDWF i, W, ACCESS
1D3C  6E13     MOVWF quotient, ACCESS
1D3E  0E00     MOVLW 0x0
1D40  203D     ADDWFC 0x3D, W, ACCESS
1D42  6E14     MOVWF 0x14, ACCESS
1D44  C032     MOVFF n, p
1D46  F015     NOP
1D48  C033     MOVFF p, i
1D4A  F016     NOP
1D4C  ECAC     CALL 0x2758, 0
1D4E  F013     NOP
1D50  C011     MOVFF counter, fp
1D52  F01C     NOP
1D54  C012     MOVFF sign, 0x1D
1D56  F01D     NOP
542:           }
1D58  0012     RETURN 0
543:           #endif
544:           
545:           #ifdef _VFPF_S
546:           static _INLINE int stoa(FILE *fp, char *s)
547:           {
548:               char *cp, nuls[] = "(null)";
1FE2  EE20     LFSR 2, 0xC6
549:               int i, l, p, w;
550:           
551:               /* Check for null string */
552:               cp = s;
1FF4  C00C     MOVFF fp, cp
1FF6  F01A     NOP
1FF8  C00D     MOVFF 0xD, 0x1B
1FFA  F01B     NOP
553:               if (!cp) {
1FFC  501A     MOVF cp, W, ACCESS
1FFE  101B     IORWF 0x1B, W, ACCESS
2000  A4D8     BTFSS STATUS, 2, ACCESS
2002  D004     BRA 0x200C
554:                   cp = nuls;
2004  0E0F     MOVLW 0xF
2006  6E1A     MOVWF cp, ACCESS
2008  0E00     MOVLW 0x0
200A  6E1B     MOVWF 0x1B, ACCESS
555:               }
556:           
557:               /* Get length, precision, width */
558:               l = strlen(cp);
200C  C01A     MOVFF cp, __pcstackCOMRAM
200E  F001     NOP
2010  C01B     MOVFF 0x1B, 0x2
2012  F002     NOP
2014  EC99     CALL 0x2B32, 0
2016  F015     NOP
2018  C001     MOVFF __pcstackCOMRAM, d
201A  F01E     NOP
201C  C002     MOVFF 0x2, w
201E  F01F     NOP
559:               p = prec;
2020  C0A4     MOVFF prec, fp
2022  F01C     NOP
2024  C0A5     MOVFF 0xA5, 0x1D
2026  F01D     NOP
560:               l = (!(p < 0) && (p < l)) ? p : l;
2028  BE1D     BTFSC 0x1D, 7, ACCESS
202A  D00E     BRA 0x2048
202C  501E     MOVF d, W, ACCESS
202E  5C1C     SUBWF fp, W, ACCESS
2030  501D     MOVF 0x1D, W, ACCESS
2032  0A80     XORLW 0x80
2034  6E0E     MOVWF c, ACCESS
2036  501F     MOVF w, W, ACCESS
2038  0A80     XORLW 0x80
203A  580E     SUBWFB c, W, ACCESS
203C  B0D8     BTFSC STATUS, 0, ACCESS
203E  D004     BRA 0x2048
2040  C01C     MOVFF fp, d
2042  F01E     NOP
2044  C01D     MOVFF 0x1D, w
2046  F01F     NOP
561:               p = l;
2048  C01E     MOVFF d, fp
204A  F01C     NOP
204C  C01F     MOVFF w, 0x1D
204E  F01D     NOP
562:               w = width;
2050  C0A2     MOVFF width, w
2052  F018     NOP
2054  C0A3     MOVFF 0xA3, counter
2056  F019     NOP
563:           
564:               /* Right justify, pad on left ? */
565:               if (!(flags & MINUS_FLAG)) {
2058  A05D     BTFSS flags, 0, ACCESS
205A  D00D     BRA 0x2076
205C  D016     BRA 0x208A
566:                   while (l < w) {
2076  5018     MOVF w, W, ACCESS
2078  5C1E     SUBWF d, W, ACCESS
207A  501F     MOVF w, W, ACCESS
207C  0A80     XORLW 0x80
207E  6E0E     MOVWF c, ACCESS
2080  5019     MOVF counter, W, ACCESS
2082  0A80     XORLW 0x80
2084  580E     SUBWFB c, W, ACCESS
2086  A0D8     BTFSS STATUS, 0, ACCESS
2088  D7EA     BRA 0x205E
567:                       fputc(' ', fp);
205E  0E00     MOVLW 0x0
2060  6E02     MOVWF 0x2, ACCESS
2062  0E20     MOVLW 0x20
2064  6E01     MOVWF __pcstackCOMRAM, ACCESS
2066  C00A     MOVFF s, fp
2068  F003     NOP
206A  C00B     MOVFF csize, data
206C  F004     NOP
206E  EC5C     CALL 0x26B8, 0
2070  F013     NOP
568:                       ++l;
2072  4A1E     INFSNZ d, F, ACCESS
2074  2A1F     INCF w, F, ACCESS
569:                   }
570:               }
571:           
572:               /* Put out string */
573:               i = 0;
208A  0E00     MOVLW 0x0
208C  6E17     MOVWF 0x17, ACCESS
208E  0E00     MOVLW 0x0
2090  6E16     MOVWF i, ACCESS
574:               while (i < p) {
2092  D013     BRA 0x20BA
20BA  501C     MOVF fp, W, ACCESS
20BC  5C16     SUBWF i, W, ACCESS
20BE  5017     MOVF 0x17, W, ACCESS
20C0  0A80     XORLW 0x80
20C2  6E0E     MOVWF c, ACCESS
20C4  501D     MOVF 0x1D, W, ACCESS
20C6  0A80     XORLW 0x80
20C8  580E     SUBWFB c, W, ACCESS
20CA  A0D8     BTFSS STATUS, 0, ACCESS
20CC  D7E3     BRA 0x2094
575:                   fputc(*cp, fp);
2094  C01A     MOVFF cp, FSR2
2096  FFD9     NOP
2098  C01B     MOVFF 0x1B, FSR2H
209A  FFDA     NOP
209C  50DF     MOVF INDF2, W, ACCESS
209E  6E0E     MOVWF c, ACCESS
20A0  500E     MOVF c, W, ACCESS
20A2  6E01     MOVWF __pcstackCOMRAM, ACCESS
20A4  6A02     CLRF 0x2, ACCESS
20A6  C00A     MOVFF s, fp
20A8  F003     NOP
20AA  C00B     MOVFF csize, data
20AC  F004     NOP
20AE  EC5C     CALL 0x26B8, 0
20B0  F013     NOP
576:                   ++cp;
20B2  4A1A     INFSNZ cp, F, ACCESS
20B4  2A1B     INCF 0x1B, F, ACCESS
577:                   ++i;
20B6  4A16     INFSNZ i, F, ACCESS
20B8  2A17     INCF 0x17, F, ACCESS
578:               }
579:           
580:               /* Left justify, pad on right ? */
581:               if (flags & MINUS_FLAG) {
20CE  B05D     BTFSC flags, 0, ACCESS
20D0  D00D     BRA 0x20EC
20D2  D016     BRA 0x2100
582:                   while (l < w) {
20EC  5018     MOVF w, W, ACCESS
20EE  5C1E     SUBWF d, W, ACCESS
20F0  501F     MOVF w, W, ACCESS
20F2  0A80     XORLW 0x80
20F4  6E0E     MOVWF c, ACCESS
20F6  5019     MOVF counter, W, ACCESS
20F8  0A80     XORLW 0x80
20FA  580E     SUBWFB c, W, ACCESS
20FC  A0D8     BTFSS STATUS, 0, ACCESS
20FE  D7EA     BRA 0x20D4
583:                       fputc(' ', fp);
20D4  0E00     MOVLW 0x0
20D6  6E02     MOVWF 0x2, ACCESS
20D8  0E20     MOVLW 0x20
20DA  6E01     MOVWF __pcstackCOMRAM, ACCESS
20DC  C00A     MOVFF s, fp
20DE  F003     NOP
20E0  C00B     MOVFF csize, data
20E2  F004     NOP
20E4  EC5C     CALL 0x26B8, 0
20E6  F013     NOP
584:                       ++l;
20E8  4A1E     INFSNZ d, F, ACCESS
20EA  2A1F     INCF w, F, ACCESS
585:                   }
586:               }
587:           
588:               return l;
2100  C01E     MOVFF d, s
2102  F00A     NOP
2104  C01F     MOVFF w, csize
2106  F00B     NOP
589:           }
2108  0012     RETURN 0
590:           #endif
591:           
592:           #ifdef _VFPF_U
593:           static _INLINE int utoa(FILE *fp, unsigned long long d)
594:           {
595:               int i, p, w;
596:               unsigned long long n;
597:           
598:               /* Adjust flags, precision, width */
599:               if (!(prec < 0)) {
1A2E  0100     MOVLB 0x0
600:                   flags &= ~ZERO_FLAG;
1A32  925D     BCF flags, 1, ACCESS
601:               }
602:               p = (0 < prec) ? prec : 1;
1A34  BFA5     BTFSC 0xA5, 7, BANKED
1A36  D005     BRA 0x1A42
1A38  51A5     MOVF 0xA5, W, BANKED
1A3A  E108     BNZ 0x1A4C
1A3C  05A4     DECF prec, W, BANKED
1A3E  B0D8     BTFSC STATUS, 0, ACCESS
1A40  D005     BRA 0x1A4C
1A42  0E00     MOVLW 0x0
1A44  6E2F     MOVWF 0x2F, ACCESS
1A46  0E01     MOVLW 0x1
1A48  6E2E     MOVWF p, ACCESS
1A4A  D004     BRA 0x1A54
1A4C  C0A4     MOVFF prec, p
1A4E  F02E     NOP
1A50  C0A5     MOVFF 0xA5, 0x2F
1A52  F02F     NOP
603:               w = width;
1A54  C0A2     MOVFF width, w
1A56  F030     NOP
1A58  C0A3     MOVFF 0xA3, 0x31
1A5A  F031     NOP
604:           
605:               /* Convert to decimal, possibly filling on the left with zeroes */
606:               n = d;
1A5C  C01E     MOVFF d, n
1A5E  F032     NOP
1A60  C01F     MOVFF w, p
1A62  F033     NOP
1A64  C020     MOVFF 0x20, n
1A66  F034     NOP
1A68  C021     MOVFF 0x21, w
1A6A  F035     NOP
1A6C  C022     MOVFF 0x22, n
1A6E  F036     NOP
1A70  C023     MOVFF 0x23, n
1A72  F037     NOP
1A74  C024     MOVFF 0x24, 0x38
1A76  F038     NOP
1A78  C025     MOVFF 0x25, 0x39
1A7A  F039     NOP
607:               i = sizeof(dbuf) - 1;
1A7C  0E00     MOVLW 0x0
1A7E  6E3B     MOVWF 0x3B, ACCESS
1A80  0E1F     MOVLW 0x1F
1A82  6E3A     MOVWF i, ACCESS
608:               dbuf[i] = '\0';
1A84  0E00     MOVLW 0x0
1A86  6FC5     MOVWF 0xC5, BANKED
609:               while (i && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
1A88  D076     BRA 0x1B76
1B76  503A     MOVF i, W, ACCESS
1B78  103B     IORWF 0x3B, W, ACCESS
1B7A  B4D8     BTFSC STATUS, 2, ACCESS
1B7C  D01A     BRA 0x1BB2
1B7E  5032     MOVF n, W, ACCESS
1B80  1033     IORWF p, W, ACCESS
1B82  1034     IORWF n, W, ACCESS
1B84  1035     IORWF w, W, ACCESS
1B86  1036     IORWF n, W, ACCESS
1B88  1037     IORWF n, W, ACCESS
1B8A  1038     IORWF 0x38, W, ACCESS
1B8C  1039     IORWF 0x39, W, ACCESS
1B8E  A4D8     BTFSS STATUS, 2, ACCESS
1B90  D77C     BRA 0x1A8A
1B92  BE2F     BTFSC 0x2F, 7, ACCESS
1B94  D005     BRA 0x1BA0
1B96  502F     MOVF 0x2F, W, ACCESS
1B98  E102     BNZ 0x1B9E
1B9A  042E     DECF p, W, ACCESS
1B9C  B0D8     BTFSC STATUS, 0, ACCESS
1B9E  D775     BRA 0x1A8A
1BA0  BE31     BTFSC 0x31, 7, ACCESS
1BA2  D007     BRA 0x1BB2
1BA4  5031     MOVF 0x31, W, ACCESS
1BA6  E103     BNZ 0x1BAE
1BA8  0430     DECF w, W, ACCESS
1BAA  A0D8     BTFSS STATUS, 0, ACCESS
1BAC  D002     BRA 0x1BB2
1BAE  B25D     BTFSC flags, 1, ACCESS
1BB0  D76C     BRA 0x1A8A
610:                   --i;
1A8A  063A     DECF i, F, ACCESS
1A8C  A0D8     BTFSS STATUS, 0, ACCESS
1A8E  063B     DECF 0x3B, F, ACCESS
611:                   dbuf[i] = '0' + (n % 10);
1A90  0EA6     MOVLW 0xA6
1A92  243A     ADDWF i, W, ACCESS
1A94  6ED9     MOVWF FSR2, ACCESS
1A96  0E00     MOVLW 0x0
1A98  203B     ADDWFC 0x3B, W, ACCESS
1A9A  6EDA     MOVWF FSR2H, ACCESS
1A9C  C032     MOVFF n, __pcstackCOMRAM
1A9E  F001     NOP
1AA0  C033     MOVFF p, 0x2
1AA2  F002     NOP
1AA4  C034     MOVFF n, fp
1AA6  F003     NOP
1AA8  C035     MOVFF w, data
1AAA  F004     NOP
1AAC  C036     MOVFF n, product
1AAE  F005     NOP
1AB0  C037     MOVFF n, 0x6
1AB2  F006     NOP
1AB4  C038     MOVFF 0x38, c
1AB6  F007     NOP
1AB8  C039     MOVFF 0x39, s
1ABA  F008     NOP
1ABC  0E0A     MOVLW 0xA
1ABE  6E09     MOVWF divisor, ACCESS
1AC0  0E00     MOVLW 0x0
1AC2  6E0A     MOVWF s, ACCESS
1AC4  0E00     MOVLW 0x0
1AC6  6E0B     MOVWF csize, ACCESS
1AC8  0E00     MOVLW 0x0
1ACA  6E0C     MOVWF fp, ACCESS
1ACC  0E00     MOVLW 0x0
1ACE  6E0D     MOVWF 0xD, ACCESS
1AD0  0E00     MOVLW 0x0
1AD2  6E0E     MOVWF c, ACCESS
1AD4  0E00     MOVLW 0x0
1AD6  6E0F     MOVWF i, ACCESS
1AD8  0E00     MOVLW 0x0
1ADA  6E10     MOVWF 0x10, ACCESS
1ADC  EC5C     CALL 0x24B8, 0
1ADE  F012     NOP
1AE0  C001     MOVFF __pcstackCOMRAM, x
1AE2  F026     NOP
1AE4  C002     MOVFF 0x2, 0x27
1AE6  F027     NOP
1AE8  C003     MOVFF fp, 0x28
1AEA  F028     NOP
1AEC  C004     MOVFF data, 0x29
1AEE  F029     NOP
1AF0  C005     MOVFF product, 0x2A
1AF2  F02A     NOP
1AF4  C006     MOVFF 0x6, 0x2B
1AF6  F02B     NOP
1AF8  C007     MOVFF c, 0x2C
1AFA  F02C     NOP
1AFC  C008     MOVFF s, 0x2D
1AFE  F02D     NOP
1B00  5026     MOVF x, W, ACCESS
1B02  0F30     ADDLW 0x30
1B04  6EDF     MOVWF INDF2, ACCESS
612:                   --p;
1B06  062E     DECF p, F, ACCESS
1B08  A0D8     BTFSS STATUS, 0, ACCESS
1B0A  062F     DECF 0x2F, F, ACCESS
613:                   --w;
1B0C  0630     DECF w, F, ACCESS
1B0E  A0D8     BTFSS STATUS, 0, ACCESS
1B10  0631     DECF 0x31, F, ACCESS
614:                   n = n / 10;
1B12  C032     MOVFF n, __pcstackCOMRAM
1B14  F001     NOP
1B16  C033     MOVFF p, 0x2
1B18  F002     NOP
1B1A  C034     MOVFF n, fp
1B1C  F003     NOP
1B1E  C035     MOVFF w, data
1B20  F004     NOP
1B22  C036     MOVFF n, product
1B24  F005     NOP
1B26  C037     MOVFF n, 0x6
1B28  F006     NOP
1B2A  C038     MOVFF 0x38, c
1B2C  F007     NOP
1B2E  C039     MOVFF 0x39, s
1B30  F008     NOP
1B32  0E0A     MOVLW 0xA
1B34  6E09     MOVWF divisor, ACCESS
1B36  0E00     MOVLW 0x0
1B38  6E0A     MOVWF s, ACCESS
1B3A  0E00     MOVLW 0x0
1B3C  6E0B     MOVWF csize, ACCESS
1B3E  0E00     MOVLW 0x0
1B40  6E0C     MOVWF fp, ACCESS
1B42  0E00     MOVLW 0x0
1B44  6E0D     MOVWF 0xD, ACCESS
1B46  0E00     MOVLW 0x0
1B48  6E0E     MOVWF c, ACCESS
1B4A  0E00     MOVLW 0x0
1B4C  6E0F     MOVWF i, ACCESS
1B4E  0E00     MOVLW 0x0
1B50  6E10     MOVWF 0x10, ACCESS
1B52  ECF5     CALL 0x23EA, 0
1B54  F011     NOP
1B56  C001     MOVFF __pcstackCOMRAM, n
1B58  F032     NOP
1B5A  C002     MOVFF 0x2, p
1B5C  F033     NOP
1B5E  C003     MOVFF fp, n
1B60  F034     NOP
1B62  C004     MOVFF data, w
1B64  F035     NOP
1B66  C005     MOVFF product, n
1B68  F036     NOP
1B6A  C006     MOVFF 0x6, n
1B6C  F037     NOP
1B6E  C007     MOVFF c, 0x38
1B70  F038     NOP
1B72  C008     MOVFF s, 0x39
1B74  F039     NOP
615:               }
616:           
617:               /* Put out padded string */
618:               return pad(fp, &dbuf[i], w);
1BB2  C01C     MOVFF fp, counter
1BB4  F011     NOP
1BB6  C01D     MOVFF 0x1D, sign
1BB8  F012     NOP
1BBA  0EA6     MOVLW 0xA6
1BBC  243A     ADDWF i, W, ACCESS
1BBE  6E13     MOVWF quotient, ACCESS
1BC0  0E00     MOVLW 0x0
1BC2  203B     ADDWFC 0x3B, W, ACCESS
1BC4  6E14     MOVWF 0x14, ACCESS
1BC6  C030     MOVFF w, p
1BC8  F015     NOP
1BCA  C031     MOVFF 0x31, i
1BCC  F016     NOP
1BCE  ECAC     CALL 0x2758, 0
1BD0  F013     NOP
1BD2  C011     MOVFF counter, fp
1BD4  F01C     NOP
1BD6  C012     MOVFF sign, 0x1D
1BD8  F01D     NOP
619:           }
1BDA  0012     RETURN 0
620:           #endif
621:           
622:           #if defined(_VFPF_X) || defined(_VFPF_P)
623:           static _INLINE int xtoa(FILE *fp, unsigned long long d, char x)
624:           {
625:               int c, i, p, w;
626:               unsigned long long n;
627:           
628:               /* Adjust, flags, precision, width */
629:               if (!(prec < 0)) {
1802  0100     MOVLB 0x0
630:                   flags &= ~ZERO_FLAG;
1806  925D     BCF flags, 1, ACCESS
631:               }
632:               p = (0 < prec) ? prec : 1;
1808  BFA5     BTFSC 0xA5, 7, BANKED
180A  D005     BRA 0x1816
180C  51A5     MOVF 0xA5, W, BANKED
180E  E108     BNZ 0x1820
1810  05A4     DECF prec, W, BANKED
1812  B0D8     BTFSC STATUS, 0, ACCESS
1814  D005     BRA 0x1820
1816  0E00     MOVLW 0x0
1818  6E34     MOVWF n, ACCESS
181A  0E01     MOVLW 0x1
181C  6E33     MOVWF p, ACCESS
181E  D004     BRA 0x1828
1820  C0A4     MOVFF prec, p
1822  F033     NOP
1824  C0A5     MOVFF 0xA5, n
1826  F034     NOP
633:               w = width;
1828  C0A2     MOVFF width, w
182A  F035     NOP
182C  C0A3     MOVFF 0xA3, n
182E  F036     NOP
634:               if (flags & POUND_FLAG) {
1830  A85D     BTFSS flags, 4, ACCESS
1832  D004     BRA 0x183C
635:                   w -= 2;
1834  0EFE     MOVLW 0xFE
1836  2635     ADDWF w, F, ACCESS
1838  0EFF     MOVLW 0xFF
183A  2236     ADDWFC n, F, ACCESS
636:               }
637:           
638:               /* Convert to hexadecimal, possibly filling on the left with zeroes */
639:               n = d;
183C  C01E     MOVFF d, n
183E  F037     NOP
1840  C01F     MOVFF w, 0x38
1842  F038     NOP
1844  C020     MOVFF 0x20, 0x39
1846  F039     NOP
1848  C021     MOVFF 0x21, i
184A  F03A     NOP
184C  C022     MOVFF 0x22, 0x3B
184E  F03B     NOP
1850  C023     MOVFF 0x23, i
1852  F03C     NOP
1854  C024     MOVFF 0x24, 0x3D
1856  F03D     NOP
1858  C025     MOVFF 0x25, i
185A  F03E     NOP
640:               i = sizeof(dbuf) - 1;
185C  0E00     MOVLW 0x0
185E  6E40     MOVWF 0x40, ACCESS
1860  0E1F     MOVLW 0x1F
1862  6E3F     MOVWF i, ACCESS
641:               dbuf[i] = '\0';
1864  0E00     MOVLW 0x0
1866  6FC5     MOVWF 0xC5, BANKED
642:               while (!(i < 2) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
1868  D093     BRA 0x1990
1990  BE40     BTFSC 0x40, 7, ACCESS
1992  D020     BRA 0x19D4
1994  5040     MOVF 0x40, W, ACCESS
1996  E104     BNZ 0x19A0
1998  0E02     MOVLW 0x2
199A  5C3F     SUBWF i, W, ACCESS
199C  A0D8     BTFSS STATUS, 0, ACCESS
199E  D01A     BRA 0x19D4
19A0  5037     MOVF n, W, ACCESS
19A2  1038     IORWF 0x38, W, ACCESS
19A4  1039     IORWF 0x39, W, ACCESS
19A6  103A     IORWF i, W, ACCESS
19A8  103B     IORWF 0x3B, W, ACCESS
19AA  103C     IORWF i, W, ACCESS
19AC  103D     IORWF 0x3D, W, ACCESS
19AE  103E     IORWF i, W, ACCESS
19B0  A4D8     BTFSS STATUS, 2, ACCESS
19B2  D75B     BRA 0x186A
19B4  BE34     BTFSC n, 7, ACCESS
19B6  D005     BRA 0x19C2
19B8  5034     MOVF n, W, ACCESS
19BA  E102     BNZ 0x19C0
19BC  0433     DECF p, W, ACCESS
19BE  B0D8     BTFSC STATUS, 0, ACCESS
19C0  D754     BRA 0x186A
19C2  BE36     BTFSC n, 7, ACCESS
19C4  D007     BRA 0x19D4
19C6  5036     MOVF n, W, ACCESS
19C8  E103     BNZ 0x19D0
19CA  0435     DECF w, W, ACCESS
19CC  A0D8     BTFSS STATUS, 0, ACCESS
19CE  D002     BRA 0x19D4
19D0  B25D     BTFSC flags, 1, ACCESS
19D2  D74B     BRA 0x186A
643:                   --i;
186A  063F     DECF i, F, ACCESS
186C  A0D8     BTFSS STATUS, 0, ACCESS
186E  0640     DECF 0x40, F, ACCESS
644:                   c = n & 0x0f;
1870  0E0F     MOVLW 0xF
1872  1437     ANDWF n, W, ACCESS
1874  6E41     MOVWF c, ACCESS
1876  6A42     CLRF 0x42, ACCESS
645:                   c = (c < 10) ? '0' + c : 'a' + (c - 10);
1878  BE42     BTFSC 0x42, 7, ACCESS
187A  D008     BRA 0x188C
187C  5042     MOVF 0x42, W, ACCESS
187E  E104     BNZ 0x1888
1880  0E0A     MOVLW 0xA
1882  5C41     SUBWF c, W, ACCESS
1884  A0D8     BTFSS STATUS, 0, ACCESS
1886  D002     BRA 0x188C
1888  0E57     MOVLW 0x57
188A  D001     BRA 0x188E
188C  0E30     MOVLW 0x30
188E  2441     ADDWF c, W, ACCESS
1890  6E41     MOVWF c, ACCESS
1892  0E00     MOVLW 0x0
1894  2042     ADDWFC 0x42, W, ACCESS
1896  6E42     MOVWF 0x42, ACCESS
646:                   if (isupper((int)x) && isalpha(c)) {
1898  0EBF     MOVLW 0xBF
189A  6E27     MOVWF 0x27, ACCESS
189C  0EFF     MOVLW 0xFF
189E  6E28     MOVWF 0x28, ACCESS
18A0  5026     MOVF x, W, ACCESS
18A2  6E29     MOVWF 0x29, ACCESS
18A4  6A2A     CLRF 0x2A, ACCESS
18A6  5027     MOVF 0x27, W, ACCESS
18A8  2629     ADDWF 0x29, F, ACCESS
18AA  5028     MOVF 0x28, W, ACCESS
18AC  222A     ADDWFC 0x2A, F, ACCESS
18AE  502A     MOVF 0x2A, W, ACCESS
18B0  E106     BNZ 0x18BE
18B2  0E1A     MOVLW 0x1A
18B4  5C29     SUBWF 0x29, W, ACCESS
18B6  B0D8     BTFSC STATUS, 0, ACCESS
18B8  D002     BRA 0x18BE
18BA  0E01     MOVLW 0x1
18BC  D001     BRA 0x18C0
18BE  0E00     MOVLW 0x0
18C0  6E2F     MOVWF 0x2F, ACCESS
18C2  6A30     CLRF w, ACCESS
18C4  502F     MOVF 0x2F, W, ACCESS
18C6  1030     IORWF w, W, ACCESS
18C8  B4D8     BTFSC STATUS, 2, ACCESS
18CA  D027     BRA 0x191A
18CC  0E9F     MOVLW 0x9F
18CE  6E27     MOVWF 0x27, ACCESS
18D0  0EFF     MOVLW 0xFF
18D2  6E28     MOVWF 0x28, ACCESS
18D4  0E20     MOVLW 0x20
18D6  1041     IORWF c, W, ACCESS
18D8  6E29     MOVWF 0x29, ACCESS
18DA  0E00     MOVLW 0x0
18DC  1042     IORWF 0x42, W, ACCESS
18DE  6E2A     MOVWF 0x2A, ACCESS
18E0  5027     MOVF 0x27, W, ACCESS
18E2  2629     ADDWF 0x29, F, ACCESS
18E4  5028     MOVF 0x28, W, ACCESS
18E6  222A     ADDWFC 0x2A, F, ACCESS
18E8  502A     MOVF 0x2A, W, ACCESS
18EA  E106     BNZ 0x18F8
18EC  0E1A     MOVLW 0x1A
18EE  5C29     SUBWF 0x29, W, ACCESS
18F0  B0D8     BTFSC STATUS, 0, ACCESS
18F2  D002     BRA 0x18F8
18F4  0E01     MOVLW 0x1
18F6  D001     BRA 0x18FA
18F8  0E00     MOVLW 0x0
18FA  6E31     MOVWF 0x31, ACCESS
18FC  6A32     CLRF n, ACCESS
18FE  5031     MOVF 0x31, W, ACCESS
1900  1032     IORWF n, W, ACCESS
1902  B4D8     BTFSC STATUS, 2, ACCESS
1904  D00A     BRA 0x191A
647:                       c = toupper(c);
1906  C041     MOVFF c, c
1908  F007     NOP
190A  C042     MOVFF 0x42, s
190C  F008     NOP
190E  EC49     CALL 0x2892, 0
1910  F014     NOP
1912  C007     MOVFF c, c
1914  F041     NOP
1916  C008     MOVFF s, 0x42
1918  F042     NOP
648:                   }
649:                   dbuf[i] = (char)c;
191A  0EA6     MOVLW 0xA6
191C  243F     ADDWF i, W, ACCESS
191E  6ED9     MOVWF FSR2, ACCESS
1920  0E00     MOVLW 0x0
1922  2040     ADDWFC 0x40, W, ACCESS
1924  6EDA     MOVWF FSR2H, ACCESS
1926  C041     MOVFF c, INDF2
1928  FFDF     NOP
650:                   --p;
192A  0633     DECF p, F, ACCESS
192C  A0D8     BTFSS STATUS, 0, ACCESS
192E  0634     DECF n, F, ACCESS
651:                   --w;
1930  0635     DECF w, F, ACCESS
1932  A0D8     BTFSS STATUS, 0, ACCESS
1934  0636     DECF n, F, ACCESS
652:                   n = n >> 4;
1936  C037     MOVFF n, 0x27
1938  F027     NOP
193A  C038     MOVFF 0x38, 0x28
193C  F028     NOP
193E  C039     MOVFF 0x39, 0x29
1940  F029     NOP
1942  C03A     MOVFF i, 0x2A
1944  F02A     NOP
1946  C03B     MOVFF 0x3B, 0x2B
1948  F02B     NOP
194A  C03C     MOVFF i, 0x2C
194C  F02C     NOP
194E  C03D     MOVFF 0x3D, 0x2D
1950  F02D     NOP
1952  C03E     MOVFF i, p
1954  F02E     NOP
1956  0E05     MOVLW 0x5
1958  D009     BRA 0x196C
195A  90D8     BCF STATUS, 0, ACCESS
195C  322E     RRCF p, F, ACCESS
195E  322D     RRCF 0x2D, F, ACCESS
1960  322C     RRCF 0x2C, F, ACCESS
1962  322B     RRCF 0x2B, F, ACCESS
1964  322A     RRCF 0x2A, F, ACCESS
1966  3229     RRCF 0x29, F, ACCESS
1968  3228     RRCF 0x28, F, ACCESS
196A  3227     RRCF 0x27, F, ACCESS
196C  2EE8     DECFSZ WREG, F, ACCESS
196E  D7F5     BRA 0x195A
1970  C027     MOVFF 0x27, n
1972  F037     NOP
1974  C028     MOVFF 0x28, 0x38
1976  F038     NOP
1978  C029     MOVFF 0x29, 0x39
197A  F039     NOP
197C  C02A     MOVFF 0x2A, i
197E  F03A     NOP
1980  C02B     MOVFF 0x2B, 0x3B
1982  F03B     NOP
1984  C02C     MOVFF 0x2C, i
1986  F03C     NOP
1988  C02D     MOVFF 0x2D, 0x3D
198A  F03D     NOP
198C  C02E     MOVFF p, i
198E  F03E     NOP
653:               }
654:           
655:               /* Display prefix if required */
656:               if (flags & POUND_FLAG) {
19D4  A85D     BTFSS flags, 4, ACCESS
19D6  D016     BRA 0x1A04
657:                   --i;
19D8  063F     DECF i, F, ACCESS
19DA  A0D8     BTFSS STATUS, 0, ACCESS
19DC  0640     DECF 0x40, F, ACCESS
658:                   dbuf[i] = x;
19DE  0EA6     MOVLW 0xA6
19E0  243F     ADDWF i, W, ACCESS
19E2  6ED9     MOVWF FSR2, ACCESS
19E4  0E00     MOVLW 0x0
19E6  2040     ADDWFC 0x40, W, ACCESS
19E8  6EDA     MOVWF FSR2H, ACCESS
19EA  C026     MOVFF x, INDF2
19EC  FFDF     NOP
659:                   --i;
19EE  063F     DECF i, F, ACCESS
19F0  A0D8     BTFSS STATUS, 0, ACCESS
19F2  0640     DECF 0x40, F, ACCESS
660:                   dbuf[i] = '0';
19F4  0EA6     MOVLW 0xA6
19F6  243F     ADDWF i, W, ACCESS
19F8  6ED9     MOVWF FSR2, ACCESS
19FA  0E00     MOVLW 0x0
19FC  2040     ADDWFC 0x40, W, ACCESS
19FE  6EDA     MOVWF FSR2H, ACCESS
1A00  0E30     MOVLW 0x30
1A02  6EDF     MOVWF INDF2, ACCESS
661:               }
662:           
663:               /* Put out padded string */
664:               return pad(fp, &dbuf[i], w);
1A04  C01C     MOVFF fp, counter
1A06  F011     NOP
1A08  C01D     MOVFF 0x1D, sign
1A0A  F012     NOP
1A0C  0EA6     MOVLW 0xA6
1A0E  243F     ADDWF i, W, ACCESS
1A10  6E13     MOVWF quotient, ACCESS
1A12  0E00     MOVLW 0x0
1A14  2040     ADDWFC 0x40, W, ACCESS
1A16  6E14     MOVWF 0x14, ACCESS
1A18  C035     MOVFF w, p
1A1A  F015     NOP
1A1C  C036     MOVFF n, i
1A1E  F016     NOP
1A20  ECAC     CALL 0x2758, 0
1A22  F013     NOP
1A24  C011     MOVFF counter, fp
1A26  F01C     NOP
1A28  C012     MOVFF sign, 0x1D
1A2A  F01D     NOP
665:           }
1A2C  0012     RETURN 0
666:           #endif
667:           
668:           /* Consume and convert the next part of the format string */
669:           #ifdef _VFPF_CONVERT
670:           static _INLINE int vfpfcnvrt(FILE *fp, char *fmt[], va_list ap)
671:           {
672:               char c, *cp, ct[3];
673:               int done, i;
674:               long long ll;
675:               unsigned long long llu;
676:               long double f;
677:               void *vp;
678:           
679:               /* Conversion ? */
680:               if ((*fmt)[0] == '%') {
084A  C045     MOVFF fmt, FSR2
681:                   ++*fmt;
0866  C045     MOVFF fmt, FSR2
0868  FFD9     NOP
086A  C046     MOVFF 0x46, FSR2H
086C  FFDA     NOP
086E  2ADE     INCF POSTINC2, F, ACCESS
0870  0E00     MOVLW 0x0
0872  22DD     ADDWFC POSTDEC2, F, ACCESS
682:           
683:                   flags = width = 0;
0874  0E00     MOVLW 0x0
0876  0100     MOVLB 0x0
0878  6FA3     MOVWF 0xA3, BANKED
087A  0E00     MOVLW 0x0
087C  6FA2     MOVWF width, BANKED
087E  C0A2     MOVFF width, flags
0880  F05D     NOP
0882  C0A3     MOVFF 0xA3, 0x5E
0884  F05E     NOP
684:                   prec = -1;
0886  69A4     SETF prec, BANKED
0888  69A5     SETF 0xA5, BANKED
685:           
686:           #ifdef _VFPF_FLAGS
687:                   /* Get flags */
688:                   done = 0;
088A  0E00     MOVLW 0x0
088C  6F63     MOVWF ttemp6, BANKED
088E  0E00     MOVLW 0x0
0890  D014     BRA 0x8BA
689:                   while (!done) {
0900  5162     MOVF done, W, BANKED
0902  1163     IORWF ttemp6, W, BANKED
0904  B4D8     BTFSC STATUS, 2, ACCESS
0906  D7DB     BRA 0x8BE
690:                       switch ((*fmt)[0]) {
691:                           case '-' :
692:                               flags |= MINUS_FLAG;
0892  805D     BSF flags, 0, ACCESS
693:                               ++*fmt;
0894  C045     MOVFF fmt, FSR2
0896  FFD9     NOP
0898  C046     MOVFF 0x46, FSR2H
089A  FFDA     NOP
089C  2ADE     INCF POSTINC2, F, ACCESS
089E  0E00     MOVLW 0x0
08A0  22DD     ADDWFC POSTDEC2, F, ACCESS
694:                               break;
08A2  D02E     BRA 0x900
695:                           case '0' :
696:                               flags |= ZERO_FLAG;
08A4  825D     BSF flags, 1, ACCESS
08A6  D7F6     BRA 0x894
697:                               ++*fmt;
698:                               break;
699:                           case '+' :
700:                               flags |= PLUS_FLAG;
08A8  845D     BSF flags, 2, ACCESS
08AA  D7F4     BRA 0x894
701:                               ++*fmt;
702:                               break;
703:                           case ' ' :
704:                               flags |= SPACE_FLAG;
08AC  865D     BSF flags, 3, ACCESS
08AE  D7F2     BRA 0x894
705:                               ++*fmt;
706:                               break;
707:                           case '#' :
708:                               flags |= POUND_FLAG;
08B0  885D     BSF flags, 4, ACCESS
08B2  D7F0     BRA 0x894
709:                               ++*fmt;
710:                               break;
711:                           default:
712:                               done = 1;
08B4  0E00     MOVLW 0x0
08B6  6F63     MOVWF ttemp6, BANKED
08B8  0E01     MOVLW 0x1
08BA  6F62     MOVWF done, BANKED
713:                               break;
08BC  D021     BRA 0x900
714:                       }
08BE  C045     MOVFF fmt, FSR2
08C0  FFD9     NOP
08C2  C046     MOVFF 0x46, FSR2H
08C4  FFDA     NOP
08C6  CFDE     MOVFF POSTINC2, TBLPTR
08C8  FFF6     NOP
08CA  CFDD     MOVFF POSTDEC2, TBLPTRH
08CC  FFF7     NOP
08CE  0008     TBLRD*
08D0  50F5     MOVF TABLAT, W, ACCESS
08D2  6E49     MOVWF 0x49, ACCESS
08D4  6A4A     CLRF 0x4A, ACCESS
08D6  504A     MOVF 0x4A, W, ACCESS
08D8  0A00     XORLW 0x0
08DA  A4D8     BTFSS STATUS, 2, ACCESS
08DC  D7EB     BRA 0x8B4
08DE  5049     MOVF 0x49, W, ACCESS
08E0  0A20     XORLW 0x20
08E2  B4D8     BTFSC STATUS, 2, ACCESS
08E4  D7E3     BRA 0x8AC
08E6  0A03     XORLW 0x3
08E8  B4D8     BTFSC STATUS, 2, ACCESS
08EA  D7E2     BRA 0x8B0
08EC  0A08     XORLW 0x8
08EE  B4D8     BTFSC STATUS, 2, ACCESS
08F0  D7DB     BRA 0x8A8
08F2  0A06     XORLW 0x6
08F4  B4D8     BTFSC STATUS, 2, ACCESS
08F6  D7CD     BRA 0x892
08F8  0A1D     XORLW 0x1D
08FA  B4D8     BTFSC STATUS, 2, ACCESS
08FC  D7D3     BRA 0x8A4
08FE  D7DA     BRA 0x8B4
715:                   }
716:                   if (flags & MINUS_FLAG) {
0908  B05D     BTFSC flags, 0, ACCESS
717:                       flags &= ~ZERO_FLAG;
090A  925D     BCF flags, 1, ACCESS
718:                   }
719:           #endif
720:           
721:           #ifdef _VFPF_WIDTH
722:                   /* Get field width */
723:                   if ((*fmt)[0] == '*') {
090C  C045     MOVFF fmt, FSR2
090E  FFD9     NOP
0910  C046     MOVFF 0x46, FSR2H
0912  FFDA     NOP
0914  CFDE     MOVFF POSTINC2, TBLPTR
0916  FFF6     NOP
0918  CFDD     MOVFF POSTDEC2, TBLPTRH
091A  FFF7     NOP
091C  0008     TBLRD*
091E  50F5     MOVF TABLAT, W, ACCESS
0920  0A2A     XORLW 0x2A
0922  A4D8     BTFSS STATUS, 2, ACCESS
0924  D023     BRA 0x96C
724:                       ++*fmt;
0926  C045     MOVFF fmt, FSR2
0928  FFD9     NOP
092A  C046     MOVFF 0x46, FSR2H
092C  FFDA     NOP
092E  2ADE     INCF POSTINC2, F, ACCESS
0930  0E00     MOVLW 0x0
0932  22DD     ADDWFC POSTDEC2, F, ACCESS
725:                       width = va_arg(ap, int);
0934  C047     MOVFF ap, FSR2
0936  FFD9     NOP
0938  C048     MOVFF 0x48, FSR2H
093A  FFDA     NOP
093C  CFDF     MOVFF INDF2, 0x49
093E  F049     NOP
0940  0E02     MOVLW 0x2
0942  26DE     ADDWF POSTINC2, F, ACCESS
0944  CFDF     MOVFF INDF2, 0x4A
0946  F04A     NOP
0948  0E00     MOVLW 0x0
094A  22DD     ADDWFC POSTDEC2, F, ACCESS
094C  C049     MOVFF 0x49, FSR2
094E  FFD9     NOP
0950  C04A     MOVFF 0x4A, FSR2H
0952  FFDA     NOP
0954  CFDE     MOVFF POSTINC2, width
0956  F0A2     NOP
0958  CFDD     MOVFF POSTDEC2, 0xA3
095A  F0A3     NOP
726:                       if (width < 0) {
095C  AFA3     BTFSS 0xA3, 7, BANKED
095E  D040     BRA 0x9E0
727:                           flags |= MINUS_FLAG;
0960  805D     BSF flags, 0, ACCESS
728:                           width = -width;
0962  6DA2     NEGF width, BANKED
0964  1FA3     COMF 0xA3, F, BANKED
0966  B0D8     BTFSC STATUS, 0, ACCESS
0968  2BA3     INCF 0xA3, F, BANKED
096A  D03A     BRA 0x9E0
729:                       }
730:                   } else {
731:                       width = atoi(*fmt);
096C  C045     MOVFF fmt, FSR2
096E  FFD9     NOP
0970  C046     MOVFF 0x46, FSR2H
0972  FFDA     NOP
0974  CFDE     MOVFF POSTINC2, s
0976  F008     NOP
0978  CFDD     MOVFF POSTDEC2, divisor
097A  F009     NOP
097C  EC51     CALL 0x1EA2, 0
097E  F00F     NOP
0980  C008     MOVFF s, width
0982  F0A2     NOP
0984  C009     MOVFF divisor, 0xA3
0986  F0A3     NOP
732:                       while (isdigit((*fmt)[0])) {
0988  D007     BRA 0x998
0998  0ED0     MOVLW 0xD0
099A  6E49     MOVWF 0x49, ACCESS
099C  0EFF     MOVLW 0xFF
099E  6E4A     MOVWF 0x4A, ACCESS
09A0  C045     MOVFF fmt, FSR2
09A2  FFD9     NOP
09A4  C046     MOVFF 0x46, FSR2H
09A6  FFDA     NOP
09A8  CFDE     MOVFF POSTINC2, TBLPTR
09AA  FFF6     NOP
09AC  CFDD     MOVFF POSTDEC2, TBLPTRH
09AE  FFF7     NOP
09B0  0008     TBLRD*
09B2  50F5     MOVF TABLAT, W, ACCESS
09B4  6E4B     MOVWF 0x4B, ACCESS
09B6  6A4C     CLRF 0x4C, ACCESS
09B8  5049     MOVF 0x49, W, ACCESS
09BA  264B     ADDWF 0x4B, F, ACCESS
09BC  504A     MOVF 0x4A, W, ACCESS
09BE  224C     ADDWFC 0x4C, F, ACCESS
09C0  504C     MOVF 0x4C, W, ACCESS
09C2  E106     BNZ 0x9D0
09C4  0E0A     MOVLW 0xA
09C6  5C4B     SUBWF 0x4B, W, ACCESS
09C8  B0D8     BTFSC STATUS, 0, ACCESS
09CA  D002     BRA 0x9D0
09CC  0E01     MOVLW 0x1
09CE  D001     BRA 0x9D2
09D0  0E00     MOVLW 0x0
09D2  0100     MOVLB 0x0
09D4  6F64     MOVWF 0x64, BANKED
09D6  6B65     CLRF 0x65, BANKED
09D8  5164     MOVF 0x64, W, BANKED
09DA  1165     IORWF 0x65, W, BANKED
09DC  A4D8     BTFSS STATUS, 2, ACCESS
09DE  D7D5     BRA 0x98A
733:                           ++*fmt;
098A  C045     MOVFF fmt, FSR2
098C  FFD9     NOP
098E  C046     MOVFF 0x46, FSR2H
0990  FFDA     NOP
0992  2ADE     INCF POSTINC2, F, ACCESS
0994  0E00     MOVLW 0x0
0996  22DD     ADDWFC POSTDEC2, F, ACCESS
734:                       }
735:                   }
736:           #endif
737:           
738:           #ifdef _VFPF_PRECISION
739:                   /* Get precision */
740:                   if ((*fmt)[0] == '.') {
09E0  C045     MOVFF fmt, FSR2
09E2  FFD9     NOP
09E4  C046     MOVFF 0x46, FSR2H
09E6  FFDA     NOP
09E8  CFDE     MOVFF POSTINC2, TBLPTR
09EA  FFF6     NOP
09EC  CFDD     MOVFF POSTDEC2, TBLPTRH
09EE  FFF7     NOP
09F0  0008     TBLRD*
09F2  50F5     MOVF TABLAT, W, ACCESS
09F4  0A2E     XORLW 0x2E
09F6  A4D8     BTFSS STATUS, 2, ACCESS
09F8  D06E     BRA 0xAD6
741:                       prec = 0;
09FA  0E00     MOVLW 0x0
09FC  6FA5     MOVWF 0xA5, BANKED
09FE  0E00     MOVLW 0x0
0A00  6FA4     MOVWF prec, BANKED
742:                       ++*fmt;
0A02  C045     MOVFF fmt, FSR2
0A04  FFD9     NOP
0A06  C046     MOVFF 0x46, FSR2H
0A08  FFDA     NOP
0A0A  2ADE     INCF POSTINC2, F, ACCESS
0A0C  0E00     MOVLW 0x0
0A0E  22DD     ADDWFC POSTDEC2, F, ACCESS
743:                       if ((*fmt)[0] == '*') {
0A10  C045     MOVFF fmt, FSR2
0A12  FFD9     NOP
0A14  C046     MOVFF 0x46, FSR2H
0A16  FFDA     NOP
0A18  CFDE     MOVFF POSTINC2, TBLPTR
0A1A  FFF6     NOP
0A1C  CFDD     MOVFF POSTDEC2, TBLPTRH
0A1E  FFF7     NOP
0A20  0008     TBLRD*
0A22  50F5     MOVF TABLAT, W, ACCESS
0A24  0A2A     XORLW 0x2A
0A26  A4D8     BTFSS STATUS, 2, ACCESS
0A28  D01C     BRA 0xA62
744:                           ++*fmt;
0A2A  C045     MOVFF fmt, FSR2
0A2C  FFD9     NOP
0A2E  C046     MOVFF 0x46, FSR2H
0A30  FFDA     NOP
0A32  2ADE     INCF POSTINC2, F, ACCESS
0A34  0E00     MOVLW 0x0
0A36  22DD     ADDWFC POSTDEC2, F, ACCESS
745:                           prec = va_arg(ap, int);
0A38  C047     MOVFF ap, FSR2
0A3A  FFD9     NOP
0A3C  C048     MOVFF 0x48, FSR2H
0A3E  FFDA     NOP
0A40  CFDF     MOVFF INDF2, 0x49
0A42  F049     NOP
0A44  0E02     MOVLW 0x2
0A46  26DE     ADDWF POSTINC2, F, ACCESS
0A48  CFDF     MOVFF INDF2, 0x4A
0A4A  F04A     NOP
0A4C  0E00     MOVLW 0x0
0A4E  22DD     ADDWFC POSTDEC2, F, ACCESS
0A50  C049     MOVFF 0x49, FSR2
0A52  FFD9     NOP
0A54  C04A     MOVFF 0x4A, FSR2H
0A56  FFDA     NOP
0A58  CFDE     MOVFF POSTINC2, prec
0A5A  F0A4     NOP
0A5C  CFDD     MOVFF POSTDEC2, 0xA5
0A5E  F0A5     NOP
746:                       } else {
0A60  D03A     BRA 0xAD6
747:                           prec = atoi(*fmt);
0A62  C045     MOVFF fmt, FSR2
0A64  FFD9     NOP
0A66  C046     MOVFF 0x46, FSR2H
0A68  FFDA     NOP
0A6A  CFDE     MOVFF POSTINC2, s
0A6C  F008     NOP
0A6E  CFDD     MOVFF POSTDEC2, divisor
0A70  F009     NOP
0A72  EC51     CALL 0x1EA2, 0
0A74  F00F     NOP
0A76  C008     MOVFF s, prec
0A78  F0A4     NOP
0A7A  C009     MOVFF divisor, 0xA5
0A7C  F0A5     NOP
748:                           while (isdigit((*fmt)[0])) {
0A7E  D007     BRA 0xA8E
0A8E  0ED0     MOVLW 0xD0
0A90  6E49     MOVWF 0x49, ACCESS
0A92  0EFF     MOVLW 0xFF
0A94  6E4A     MOVWF 0x4A, ACCESS
0A96  C045     MOVFF fmt, FSR2
0A98  FFD9     NOP
0A9A  C046     MOVFF 0x46, FSR2H
0A9C  FFDA     NOP
0A9E  CFDE     MOVFF POSTINC2, TBLPTR
0AA0  FFF6     NOP
0AA2  CFDD     MOVFF POSTDEC2, TBLPTRH
0AA4  FFF7     NOP
0AA6  0008     TBLRD*
0AA8  50F5     MOVF TABLAT, W, ACCESS
0AAA  6E4B     MOVWF 0x4B, ACCESS
0AAC  6A4C     CLRF 0x4C, ACCESS
0AAE  5049     MOVF 0x49, W, ACCESS
0AB0  264B     ADDWF 0x4B, F, ACCESS
0AB2  504A     MOVF 0x4A, W, ACCESS
0AB4  224C     ADDWFC 0x4C, F, ACCESS
0AB6  504C     MOVF 0x4C, W, ACCESS
0AB8  E106     BNZ 0xAC6
0ABA  0E0A     MOVLW 0xA
0ABC  5C4B     SUBWF 0x4B, W, ACCESS
0ABE  B0D8     BTFSC STATUS, 0, ACCESS
0AC0  D002     BRA 0xAC6
0AC2  0E01     MOVLW 0x1
0AC4  D001     BRA 0xAC8
0AC6  0E00     MOVLW 0x0
0AC8  0100     MOVLB 0x0
0ACA  6F66     MOVWF 0x66, BANKED
0ACC  6B67     CLRF ttemp7, BANKED
0ACE  5166     MOVF 0x66, W, BANKED
0AD0  1167     IORWF ttemp7, W, BANKED
0AD2  A4D8     BTFSS STATUS, 2, ACCESS
0AD4  D7D5     BRA 0xA80
749:                               ++*fmt;
0A80  C045     MOVFF fmt, FSR2
0A82  FFD9     NOP
0A84  C046     MOVFF 0x46, FSR2H
0A86  FFDA     NOP
0A88  2ADE     INCF POSTINC2, F, ACCESS
0A8A  0E00     MOVLW 0x0
0A8C  22DD     ADDWFC POSTDEC2, F, ACCESS
750:                           }
751:                       }
752:                   }
753:           #endif
754:           
755:           #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
756:                   /* Case-folded conversion types */
757:                   ct[0] = tolower((int)(*fmt)[0]);
758:                   if (ct[0]) {
759:                       ct[1] = tolower((int)(*fmt)[1]);
760:                       if (ct[1]) {
761:                           ct[2] = tolower((int)(*fmt)[2]);
762:                       }
763:                   }
764:           #endif
765:           
766:           #ifdef _VFPF_A
767:                   /* 'a' style (hex) floating point */
768:                   if (ct[0] == 'a') {
769:           
770:                       c = (*fmt)[0];
771:                       ++*fmt;
772:                       f = (long double)va_arg(ap, double);
773:                                   
774:                       return atoa(fp, f, c);
775:                   }
776:                   if (!strncmp(ct, "la", CSTRLEN("la"))) {
777:           
778:                       c = (*fmt)[1];
779:                       if (isupper((int)(*fmt)[0])) {
780:                           f = va_arg(ap, long double);
781:                       } else {
782:                           f = (long double)va_arg(ap, double);
783:                       }
784:                       *fmt += CSTRLEN("la");
785:                                   
786:                       return atoa(fp, f, c);
787:                   }
788:           #endif
789:           
790:           #ifdef _VFPF_C
791:                   /* Character */
792:                   if (*fmt[0] == 'c') {
0AD6  C045     MOVFF fmt, FSR2
0AD8  FFD9     NOP
0ADA  C046     MOVFF 0x46, FSR2H
0ADC  FFDA     NOP
0ADE  CFDE     MOVFF POSTINC2, TBLPTR
0AE0  FFF6     NOP
0AE2  CFDD     MOVFF POSTDEC2, TBLPTRH
0AE4  FFF7     NOP
0AE6  0008     TBLRD*
0AE8  50F5     MOVF TABLAT, W, ACCESS
0AEA  0A63     XORLW 0x63
0AEC  A4D8     BTFSS STATUS, 2, ACCESS
0AEE  D026     BRA 0xB3C
793:                       ++*fmt;
0AF0  C045     MOVFF fmt, FSR2
0AF2  FFD9     NOP
0AF4  C046     MOVFF 0x46, FSR2H
0AF6  FFDA     NOP
0AF8  2ADE     INCF POSTINC2, F, ACCESS
0AFA  0E00     MOVLW 0x0
0AFC  22DD     ADDWFC POSTDEC2, F, ACCESS
794:                       c = (unsigned char)va_arg(ap, int);
0AFE  C047     MOVFF ap, FSR2
0B00  FFD9     NOP
0B02  C048     MOVFF 0x48, FSR2H
0B04  FFDA     NOP
0B06  CFDF     MOVFF INDF2, 0x49
0B08  F049     NOP
0B0A  0E02     MOVLW 0x2
0B0C  26DE     ADDWF POSTINC2, F, ACCESS
0B0E  CFDF     MOVFF INDF2, 0x4A
0B10  F04A     NOP
0B12  0E00     MOVLW 0x0
0B14  22DD     ADDWFC POSTDEC2, F, ACCESS
0B16  C049     MOVFF 0x49, FSR2
0B18  FFD9     NOP
0B1A  C04A     MOVFF 0x4A, FSR2H
0B1C  FFDA     NOP
0B1E  50DF     MOVF INDF2, W, ACCESS
0B20  6F72     MOVWF c, BANKED
795:                       return ctoa(fp, c);
0B22  C043     MOVFF fp, fp
0B24  F01C     NOP
0B26  C044     MOVFF 0x44, 0x1D
0B28  F01D     NOP
0B2A  C072     MOVFF c, d
0B2C  F01E     NOP
0B2E  EC22     CALL 0x2844, 0
0B30  F014     NOP
0B32  C01C     MOVFF fp, fp
0B34  F043     NOP
0B36  C01D     MOVFF 0x1D, 0x44
0B38  F044     NOP
0B3A  0012     RETURN 0
796:                   }
797:           #endif
798:           
799:           #ifdef _VFPF_D
800:           #ifdef _VFPF_HH
801:                   /* Character decimal integer */
802:                   if (!strncmp(*fmt, "hhd", CSTRLEN("hhd")) || \
0B3C  C045     MOVFF fmt, FSR2
0B3E  FFD9     NOP
0B40  C046     MOVFF 0x46, FSR2H
0B42  FFDA     NOP
0B44  CFDE     MOVFF POSTINC2, __pcstackCOMRAM
0B46  F001     NOP
0B48  CFDD     MOVFF POSTDEC2, 0x2
0B4A  F002     NOP
0B4C  0E18     MOVLW 0x18
0B4E  6E03     MOVWF fp, ACCESS
0B50  0E08     MOVLW 0x8
0B52  6E04     MOVWF data, ACCESS
0B54  0E00     MOVLW 0x0
0B56  6E06     MOVWF 0x6, ACCESS
0B58  0E03     MOVLW 0x3
0B5A  6E05     MOVWF product, ACCESS
0B5C  ECB3     CALL 0x2566, 0
0B5E  F012     NOP
0B60  5001     MOVF __pcstackCOMRAM, W, ACCESS
0B62  1002     IORWF 0x2, W, ACCESS
0B64  B4D8     BTFSC STATUS, 2, ACCESS
0B66  D016     BRA 0xB94
0B68  C045     MOVFF fmt, FSR2
0B6A  FFD9     NOP
0B6C  C046     MOVFF 0x46, FSR2H
0B6E  FFDA     NOP
0B70  CFDE     MOVFF POSTINC2, __pcstackCOMRAM
0B72  F001     NOP
0B74  CFDD     MOVFF POSTDEC2, 0x2
0B76  F002     NOP
0B78  0E1C     MOVLW 0x1C
0B7A  6E03     MOVWF fp, ACCESS
0B7C  0E08     MOVLW 0x8
0B7E  6E04     MOVWF data, ACCESS
0B80  0E00     MOVLW 0x0
0B82  6E06     MOVWF 0x6, ACCESS
0B84  0E03     MOVLW 0x3
0B86  6E05     MOVWF product, ACCESS
0B88  ECB3     CALL 0x2566, 0
0B8A  F012     NOP
0B8C  5001     MOVF __pcstackCOMRAM, W, ACCESS
0B8E  1002     IORWF 0x2, W, ACCESS
0B90  A4D8     BTFSS STATUS, 2, ACCESS
0B92  D040     BRA 0xC14
803:                       !strncmp(*fmt, "hhi", CSTRLEN("hhi"))) {
804:           
805:                       *fmt += CSTRLEN("hhd");
0B94  0E03     MOVLW 0x3
0B96  C045     MOVFF fmt, FSR2
0B98  FFD9     NOP
0B9A  C046     MOVFF 0x46, FSR2H
0B9C  FFDA     NOP
0B9E  26DE     ADDWF POSTINC2, F, ACCESS
0BA0  0E00     MOVLW 0x0
0BA2  22DD     ADDWFC POSTDEC2, F, ACCESS
806:                       ll = (long long)(signed char)va_arg(ap, int);
0BA4  C047     MOVFF ap, FSR2
0BA6  FFD9     NOP
0BA8  C048     MOVFF 0x48, FSR2H
0BAA  FFDA     NOP
0BAC  CFDF     MOVFF INDF2, 0x49
0BAE  F049     NOP
0BB0  0E02     MOVLW 0x2
0BB2  26DE     ADDWF POSTINC2, F, ACCESS
0BB4  CFDF     MOVFF INDF2, 0x4A
0BB6  F04A     NOP
0BB8  0E00     MOVLW 0x0
0BBA  22DD     ADDWFC POSTDEC2, F, ACCESS
0BBC  C049     MOVFF 0x49, FSR2
0BBE  FFD9     NOP
0BC0  C04A     MOVFF 0x4A, FSR2H
0BC2  FFDA     NOP
0BC4  50DF     MOVF INDF2, W, ACCESS
0BC6  0100     MOVLB 0x0
0BC8  6F68     MOVWF ll, BANKED
0BCA  0E00     MOVLW 0x0
0BCC  BF68     BTFSC ll, 7, BANKED
0BCE  0EFF     MOVLW 0xFF
0BD0  6F69     MOVWF 0x69, BANKED
0BD2  6F6A     MOVWF 0x6A, BANKED
0BD4  6F6B     MOVWF 0x6B, BANKED
0BD6  6F6C     MOVWF 0x6C, BANKED
0BD8  6F6D     MOVWF 0x6D, BANKED
0BDA  6F6E     MOVWF 0x6E, BANKED
0BDC  6F6F     MOVWF 0x6F, BANKED
807:                                   
808:                       return dtoa(fp, ll);
0BDE  C043     MOVFF fp, fp
0BE0  F01C     NOP
0BE2  C044     MOVFF 0x44, 0x1D
0BE4  F01D     NOP
0BE6  C068     MOVFF ll, d
0BE8  F01E     NOP
0BEA  C069     MOVFF 0x69, w
0BEC  F01F     NOP
0BEE  C06A     MOVFF 0x6A, 0x20
0BF0  F020     NOP
0BF2  C06B     MOVFF 0x6B, 0x21
0BF4  F021     NOP
0BF6  C06C     MOVFF 0x6C, 0x22
0BF8  F022     NOP
0BFA  C06D     MOVFF 0x6D, 0x23
0BFC  F023     NOP
0BFE  C06E     MOVFF 0x6E, 0x24
0C00  F024     NOP
0C02  C06F     MOVFF 0x6F, 0x25
0C04  F025     NOP
0C06  ECE0     CALL 0x15C0, 0
0C08  F00A     NOP
0C0A  C01C     MOVFF fp, fp
0C0C  F043     NOP
0C0E  C01D     MOVFF 0x1D, 0x44
0C10  F044     NOP
0C12  0012     RETURN 0
809:                   }
810:           #endif
811:           
812:           #ifdef _VFPF_H
813:                   /* Short decimal integer */
814:                   if (!strncmp(*fmt, "hd", CSTRLEN("hd")) || \
0C14  C045     MOVFF fmt, FSR2
0C16  FFD9     NOP
0C18  C046     MOVFF 0x46, FSR2H
0C1A  FFDA     NOP
0C1C  CFDE     MOVFF POSTINC2, __pcstackCOMRAM
0C1E  F001     NOP
0C20  CFDD     MOVFF POSTDEC2, 0x2
0C22  F002     NOP
0C24  0E19     MOVLW 0x19
0C26  6E03     MOVWF fp, ACCESS
0C28  0E08     MOVLW 0x8
0C2A  6E04     MOVWF data, ACCESS
0C2C  0E00     MOVLW 0x0
0C2E  6E06     MOVWF 0x6, ACCESS
0C30  0E02     MOVLW 0x2
0C32  6E05     MOVWF product, ACCESS
0C34  ECB3     CALL 0x2566, 0
0C36  F012     NOP
0C38  5001     MOVF __pcstackCOMRAM, W, ACCESS
0C3A  1002     IORWF 0x2, W, ACCESS
0C3C  B4D8     BTFSC STATUS, 2, ACCESS
0C3E  D016     BRA 0xC6C
0C40  C045     MOVFF fmt, FSR2
0C42  FFD9     NOP
0C44  C046     MOVFF 0x46, FSR2H
0C46  FFDA     NOP
0C48  CFDE     MOVFF POSTINC2, __pcstackCOMRAM
0C4A  F001     NOP
0C4C  CFDD     MOVFF POSTDEC2, 0x2
0C4E  F002     NOP
0C50  0E1D     MOVLW 0x1D
0C52  6E03     MOVWF fp, ACCESS
0C54  0E08     MOVLW 0x8
0C56  6E04     MOVWF data, ACCESS
0C58  0E00     MOVLW 0x0
0C5A  6E06     MOVWF 0x6, ACCESS
0C5C  0E02     MOVLW 0x2
0C5E  6E05     MOVWF product, ACCESS
0C60  ECB3     CALL 0x2566, 0
0C62  F012     NOP
0C64  5001     MOVF __pcstackCOMRAM, W, ACCESS
0C66  1002     IORWF 0x2, W, ACCESS
0C68  A4D8     BTFSS STATUS, 2, ACCESS
0C6A  D007     BRA 0xC7A
815:                       !strncmp(*fmt, "hi", CSTRLEN("hi"))) {
816:           
817:                       *fmt += CSTRLEN("hd");
0C6C  0E02     MOVLW 0x2
0C6E  C045     MOVFF fmt, FSR2
0C70  FFD9     NOP
0C72  C046     MOVFF 0x46, FSR2H
0C74  FFDA     NOP
0C76  26DE     ADDWF POSTINC2, F, ACCESS
0C78  D01F     BRA 0xCB8
818:                       ll = (long long)(short)va_arg(ap, int);
819:                                   
820:                       return dtoa(fp, ll);
821:                   }
822:           #endif
823:           
824:                   /* Decimal integer */
825:                   if ((*fmt[0] == 'd') || (*fmt[0] == 'i')) {
0C7A  C045     MOVFF fmt, FSR2
0C7C  FFD9     NOP
0C7E  C046     MOVFF 0x46, FSR2H
0C80  FFDA     NOP
0C82  CFDE     MOVFF POSTINC2, TBLPTR
0C84  FFF6     NOP
0C86  CFDD     MOVFF POSTDEC2, TBLPTRH
0C88  FFF7     NOP
0C8A  0008     TBLRD*
0C8C  50F5     MOVF TABLAT, W, ACCESS
0C8E  0A64     XORLW 0x64
0C90  B4D8     BTFSC STATUS, 2, ACCESS
0C92  D00D     BRA 0xCAE
0C94  C045     MOVFF fmt, FSR2
0C96  FFD9     NOP
0C98  C046     MOVFF 0x46, FSR2H
0C9A  FFDA     NOP
0C9C  CFDE     MOVFF POSTINC2, TBLPTR
0C9E  FFF6     NOP
0CA0  CFDD     MOVFF POSTDEC2, TBLPTRH
0CA2  FFF7     NOP
0CA4  0008     TBLRD*
0CA6  50F5     MOVF TABLAT, W, ACCESS
0CA8  0A69     XORLW 0x69
0CAA  A4D8     BTFSS STATUS, 2, ACCESS
0CAC  D020     BRA 0xCEE
826:           
827:                       ++*fmt;
0CAE  C045     MOVFF fmt, FSR2
0CB0  FFD9     NOP
0CB2  C046     MOVFF 0x46, FSR2H
0CB4  FFDA     NOP
0CB6  2ADE     INCF POSTINC2, F, ACCESS
0CB8  0E00     MOVLW 0x0
0CBA  22DD     ADDWFC POSTDEC2, F, ACCESS
828:                       ll = (long long)va_arg(ap, int);
0CBC  C047     MOVFF ap, FSR2
0CBE  FFD9     NOP
0CC0  C048     MOVFF 0x48, FSR2H
0CC2  FFDA     NOP
0CC4  CFDF     MOVFF INDF2, 0x49
0CC6  F049     NOP
0CC8  0E02     MOVLW 0x2
0CCA  26DE     ADDWF POSTINC2, F, ACCESS
0CCC  CFDF     MOVFF INDF2, 0x4A
0CCE  F04A     NOP
0CD0  0E00     MOVLW 0x0
0CD2  22DD     ADDWFC POSTDEC2, F, ACCESS
0CD4  C049     MOVFF 0x49, FSR2
0CD6  FFD9     NOP
0CD8  C04A     MOVFF 0x4A, FSR2H
0CDA  FFDA     NOP
0CDC  CFDE     MOVFF POSTINC2, ll
0CDE  F068     NOP
0CE0  CFDD     MOVFF POSTDEC2, 0x69
0CE2  F069     NOP
0CE4  0100     MOVLB 0x0
0CE6  0E00     MOVLW 0x0
0CE8  BF69     BTFSC 0x69, 7, BANKED
0CEA  0EFF     MOVLW 0xFF
0CEC  D772     BRA 0xBD2
829:                                   
830:                       return dtoa(fp, ll);
831:                   }
832:           
833:           #ifdef _VFPF_L
834:                   /* Long decimal integer */
835:                   if (!strncmp(*fmt, "ld", CSTRLEN("ld")) || \
836:                       !strncmp(*fmt, "li", CSTRLEN("li"))) {
837:           
838:                       *fmt += CSTRLEN("ld");
839:                       ll = (long long)va_arg(ap, long);
840:                                   
841:                       return dtoa(fp, ll);
842:                   }
843:           #endif
844:           
845:           #ifdef _VFPF_LL
846:                   /* Long long decimal integer */
847:                   if (!strncmp(*fmt, "lld", CSTRLEN("lld")) || \
848:                       !strncmp(*fmt, "lli", CSTRLEN("lli"))) {
849:           
850:                       *fmt += CSTRLEN("lld");
851:                       ll = va_arg(ap, long long);
852:                                   
853:                       return dtoa(fp, ll);
854:                   }
855:           #endif
856:           
857:           #ifdef _VFPF_J
858:                   /* intmax_t decimal integer */
859:                   if (!strncmp(*fmt, "jd", CSTRLEN("jd")) || \
860:                       !strncmp(*fmt, "ji", CSTRLEN("ji"))) {
861:           
862:                       *fmt += CSTRLEN("jd");
863:                       ll = (long long)va_arg(ap, intmax_t);
864:                                   
865:                       return dtoa(fp, ll);
866:                   }
867:           #endif
868:           
869:           #ifdef _VFPF_T
870:                   /* ptrdiff_t decimal integer */
871:                   if (!strncmp(*fmt, "td", CSTRLEN("td")) || \
872:                       !strncmp(*fmt, "ti", CSTRLEN("ti"))) {
873:           
874:                       *fmt += CSTRLEN("td");
875:                       ll = (long long)va_arg(ap, ptrdiff_t);
876:                                   
877:                       return dtoa(fp, ll);
878:                   }
879:           #endif
880:           
881:           #ifdef _VFPF_Z
882:                   /* size_t decimal integer */
883:                   if (!strncmp(*fmt, "zd", CSTRLEN("zd")) || \
0CEE  C045     MOVFF fmt, FSR2
0CF0  FFD9     NOP
0CF2  C046     MOVFF 0x46, FSR2H
0CF4  FFDA     NOP
0CF6  CFDE     MOVFF POSTINC2, __pcstackCOMRAM
0CF8  F001     NOP
0CFA  CFDD     MOVFF POSTDEC2, 0x2
0CFC  F002     NOP
0CFE  0E33     MOVLW 0x33
0D00  6E03     MOVWF fp, ACCESS
0D02  0E08     MOVLW 0x8
0D04  6E04     MOVWF data, ACCESS
0D06  0E00     MOVLW 0x0
0D08  6E06     MOVWF 0x6, ACCESS
0D0A  0E02     MOVLW 0x2
0D0C  6E05     MOVWF product, ACCESS
0D0E  ECB3     CALL 0x2566, 0
0D10  F012     NOP
0D12  5001     MOVF __pcstackCOMRAM, W, ACCESS
0D14  1002     IORWF 0x2, W, ACCESS
0D16  B4D8     BTFSC STATUS, 2, ACCESS
0D18  D016     BRA 0xD46
0D1A  C045     MOVFF fmt, FSR2
0D1C  FFD9     NOP
0D1E  C046     MOVFF 0x46, FSR2H
0D20  FFDA     NOP
0D22  CFDE     MOVFF POSTINC2, __pcstackCOMRAM
0D24  F001     NOP
0D26  CFDD     MOVFF POSTDEC2, 0x2
0D28  F002     NOP
0D2A  0E36     MOVLW 0x36
0D2C  6E03     MOVWF fp, ACCESS
0D2E  0E08     MOVLW 0x8
0D30  6E04     MOVWF data, ACCESS
0D32  0E00     MOVLW 0x0
0D34  6E06     MOVWF 0x6, ACCESS
0D36  0E02     MOVLW 0x2
0D38  6E05     MOVWF product, ACCESS
0D3A  ECB3     CALL 0x2566, 0
0D3C  F012     NOP
0D3E  5001     MOVF __pcstackCOMRAM, W, ACCESS
0D40  1002     IORWF 0x2, W, ACCESS
0D42  A4D8     BTFSS STATUS, 2, ACCESS
0D44  D028     BRA 0xD96
884:                       !strncmp(*fmt, "zi", CSTRLEN("zi"))) {
885:           
886:                       *fmt += CSTRLEN("zd");
0D46  0E02     MOVLW 0x2
0D48  C045     MOVFF fmt, FSR2
0D4A  FFD9     NOP
0D4C  C046     MOVFF 0x46, FSR2H
0D4E  FFDA     NOP
0D50  26DE     ADDWF POSTINC2, F, ACCESS
0D52  0E00     MOVLW 0x0
0D54  22DD     ADDWFC POSTDEC2, F, ACCESS
887:                       ll = (long long)va_arg(ap, size_t);
0D56  C047     MOVFF ap, FSR2
0D58  FFD9     NOP
0D5A  C048     MOVFF 0x48, FSR2H
0D5C  FFDA     NOP
0D5E  CFDF     MOVFF INDF2, 0x49
0D60  F049     NOP
0D62  0E02     MOVLW 0x2
0D64  26DE     ADDWF POSTINC2, F, ACCESS
0D66  CFDF     MOVFF INDF2, 0x4A
0D68  F04A     NOP
0D6A  0E00     MOVLW 0x0
0D6C  22DD     ADDWFC POSTDEC2, F, ACCESS
0D6E  C049     MOVFF 0x49, FSR2
0D70  FFD9     NOP
0D72  C04A     MOVFF 0x4A, FSR2H
0D74  FFDA     NOP
0D76  CFDE     MOVFF POSTINC2, 0x4B
0D78  F04B     NOP
0D7A  CFDD     MOVFF POSTDEC2, 0x4C
0D7C  F04C     NOP
0D7E  C04B     MOVFF 0x4B, ll
0D80  F068     NOP
0D82  C04C     MOVFF 0x4C, 0x69
0D84  F069     NOP
0D86  0100     MOVLB 0x0
0D88  6B6A     CLRF 0x6A, BANKED
0D8A  6B6B     CLRF 0x6B, BANKED
0D8C  6B6C     CLRF 0x6C, BANKED
0D8E  6B6D     CLRF 0x6D, BANKED
0D90  6B6E     CLRF 0x6E, BANKED
0D92  6B6F     CLRF 0x6F, BANKED
0D94  D724     BRA 0xBDE
888:                                   
889:                       return dtoa(fp, ll);
890:                   }
891:           #endif
892:           #endif
893:           
894:           #ifdef _VFPF_E
895:                   /* 'e' style floating point */
896:                   if (ct[0] == 'e') {
897:           
898:                       c = (*fmt)[0];
899:                       ++*fmt;
900:                       f = (long double)va_arg(ap, double);
901:                                   
902:                       return efgtoa(fp, f, c);
903:                   }
904:                   if (!strncmp(ct, "le", CSTRLEN("le"))) {
905:           
906:                       c = (*fmt)[1];
907:                       if (isupper((int)(*fmt)[0])) {
908:                           f = va_arg(ap, long double);
909:                       } else {
910:                           f = (long double)va_arg(ap, double);
911:                       }
912:                       *fmt += CSTRLEN("lf");
913:                                   
914:                       return efgtoa(fp, f, c);
915:                   }
916:           #endif
917:           
918:           #ifdef _VFPF_F
919:                   /* 'f' style floating point */
920:                   if (ct[0] == 'f') {
921:           
922:                       c = (*fmt)[0];
923:                       ++*fmt;
924:                       f = (long double)va_arg(ap, double);
925:                                   
926:                       return efgtoa(fp, f, c);
927:                   }
928:                   if (!strncmp(ct, "lf", CSTRLEN("lf"))) {
929:           
930:                       c = (*fmt)[1];
931:                       if (isupper((int)(*fmt)[0])) {
932:                           f = va_arg(ap, long double);
933:                       } else {
934:                           f = (long double)va_arg(ap, double);
935:                       }
936:                       *fmt += CSTRLEN("lf");
937:                                   
938:                       return efgtoa(fp, f, c);
939:                   }
940:           #endif
941:           
942:           #ifdef _VFPF_G
943:                   /* 'g' style floating point */
944:                   if (ct[0] == 'g') {
945:           
946:                       c = (*fmt)[0];
947:                       ++*fmt;
948:                       f = (long double)va_arg(ap, double);
949:                                   
950:                       return efgtoa(fp, f, c);
951:                   }
952:                   if (!strncmp(ct, "lg", CSTRLEN("lg"))) {
953:           
954:                       c = (*fmt)[1];
955:                       if (isupper((int)(*fmt)[0])) {
956:                           f = va_arg(ap, long double);
957:                       } else {
958:                           f = (long double)va_arg(ap, double);
959:                       }
960:                       *fmt += CSTRLEN("lg");
961:                                   
962:                       return efgtoa(fp, f, c);
963:                   }
964:           #endif
965:           
966:           #ifdef _VFPF_O
967:           #ifdef _VFPF_HH
968:                   /* Character octal integer */
969:                   if (!strncmp(*fmt, "hho", CSTRLEN("hho"))) {
0D96  C045     MOVFF fmt, FSR2
0D98  FFD9     NOP
0D9A  C046     MOVFF 0x46, FSR2H
0D9C  FFDA     NOP
0D9E  CFDE     MOVFF POSTINC2, __pcstackCOMRAM
0DA0  F001     NOP
0DA2  CFDD     MOVFF POSTDEC2, 0x2
0DA4  F002     NOP
0DA6  0E24     MOVLW 0x24
0DA8  6E03     MOVWF fp, ACCESS
0DAA  0E08     MOVLW 0x8
0DAC  6E04     MOVWF data, ACCESS
0DAE  0E00     MOVLW 0x0
0DB0  6E06     MOVWF 0x6, ACCESS
0DB2  0E03     MOVLW 0x3
0DB4  6E05     MOVWF product, ACCESS
0DB6  ECB3     CALL 0x2566, 0
0DB8  F012     NOP
0DBA  5001     MOVF __pcstackCOMRAM, W, ACCESS
0DBC  1002     IORWF 0x2, W, ACCESS
0DBE  A4D8     BTFSS STATUS, 2, ACCESS
0DC0  D03F     BRA 0xE40
970:           
971:                       *fmt += CSTRLEN("hho");
0DC2  0E03     MOVLW 0x3
0DC4  C045     MOVFF fmt, FSR2
0DC6  FFD9     NOP
0DC8  C046     MOVFF 0x46, FSR2H
0DCA  FFDA     NOP
0DCC  26DE     ADDWF POSTINC2, F, ACCESS
0DCE  0E00     MOVLW 0x0
0DD0  22DD     ADDWFC POSTDEC2, F, ACCESS
972:                       llu = (unsigned long long)(unsigned char)va_arg(ap, int);
0DD2  C047     MOVFF ap, FSR2
0DD4  FFD9     NOP
0DD6  C048     MOVFF 0x48, FSR2H
0DD8  FFDA     NOP
0DDA  CFDF     MOVFF INDF2, 0x49
0DDC  F049     NOP
0DDE  0E02     MOVLW 0x2
0DE0  26DE     ADDWF POSTINC2, F, ACCESS
0DE2  CFDF     MOVFF INDF2, 0x4A
0DE4  F04A     NOP
0DE6  0E00     MOVLW 0x0
0DE8  22DD     ADDWFC POSTDEC2, F, ACCESS
0DEA  C049     MOVFF 0x49, FSR2
0DEC  FFD9     NOP
0DEE  C04A     MOVFF 0x4A, FSR2H
0DF0  FFDA     NOP
0DF2  50DF     MOVF INDF2, W, ACCESS
0DF4  6E4B     MOVWF 0x4B, ACCESS
0DF6  504B     MOVF 0x4B, W, ACCESS
0DF8  0100     MOVLB 0x0
0DFA  6F73     MOVWF llu, BANKED
0DFC  6B74     CLRF 0x74, BANKED
0DFE  6B75     CLRF 0x75, BANKED
0E00  6B76     CLRF 0x76, BANKED
0E02  6B77     CLRF 0x77, BANKED
0E04  6B78     CLRF 0x78, BANKED
0E06  6B79     CLRF 0x79, BANKED
0E08  6B7A     CLRF 0x7A, BANKED
973:                                   
974:                       return otoa(fp, llu);
0E0A  C043     MOVFF fp, fp
0E0C  F01C     NOP
0E0E  C044     MOVFF 0x44, 0x1D
0E10  F01D     NOP
0E12  C073     MOVFF llu, d
0E14  F01E     NOP
0E16  C074     MOVFF 0x74, w
0E18  F01F     NOP
0E1A  C075     MOVFF 0x75, 0x20
0E1C  F020     NOP
0E1E  C076     MOVFF 0x76, 0x21
0E20  F021     NOP
0E22  C077     MOVFF 0x77, 0x22
0E24  F022     NOP
0E26  C078     MOVFF 0x78, 0x23
0E28  F023     NOP
0E2A  C079     MOVFF 0x79, 0x24
0E2C  F024     NOP
0E2E  C07A     MOVFF 0x7A, 0x25
0E30  F025     NOP
0E32  ECEE     CALL 0x1BDC, 0
0E34  F00D     NOP
0E36  C01C     MOVFF fp, fp
0E38  F043     NOP
0E3A  C01D     MOVFF 0x1D, 0x44
0E3C  F044     NOP
0E3E  0012     RETURN 0
975:                   }
976:           #endif
977:           
978:           #ifdef _VFPF_H
979:                   /* Short octal integer */
980:                   if (!strncmp(*fmt, "ho", CSTRLEN("ho"))) {
0E40  C045     MOVFF fmt, FSR2
0E42  FFD9     NOP
0E44  C046     MOVFF 0x46, FSR2H
0E46  FFDA     NOP
0E48  CFDE     MOVFF POSTINC2, __pcstackCOMRAM
0E4A  F001     NOP
0E4C  CFDD     MOVFF POSTDEC2, 0x2
0E4E  F002     NOP
0E50  0E25     MOVLW 0x25
0E52  6E03     MOVWF fp, ACCESS
0E54  0E08     MOVLW 0x8
0E56  6E04     MOVWF data, ACCESS
0E58  0E00     MOVLW 0x0
0E5A  6E06     MOVWF 0x6, ACCESS
0E5C  0E02     MOVLW 0x2
0E5E  6E05     MOVWF product, ACCESS
0E60  ECB3     CALL 0x2566, 0
0E62  F012     NOP
0E64  5001     MOVF __pcstackCOMRAM, W, ACCESS
0E66  1002     IORWF 0x2, W, ACCESS
0E68  B4D8     BTFSC STATUS, 2, ACCESS
981:           
982:                       *fmt += CSTRLEN("ho");
0E6A  D029     BRA 0xEBE
983:                       llu = (unsigned long long)(unsigned short)va_arg(ap, int);
984:                                   
985:                       return otoa(fp, llu);
986:                   }
987:           #endif
988:           
989:                   /* Octal integer */
990:                   if (*fmt[0] == 'o') {
0E6C  C045     MOVFF fmt, FSR2
0E6E  FFD9     NOP
0E70  C046     MOVFF 0x46, FSR2H
0E72  FFDA     NOP
0E74  CFDE     MOVFF POSTINC2, TBLPTR
0E76  FFF6     NOP
0E78  CFDD     MOVFF POSTDEC2, TBLPTRH
0E7A  FFF7     NOP
0E7C  0008     TBLRD*
0E7E  50F5     MOVF TABLAT, W, ACCESS
0E80  0A6F     XORLW 0x6F
0E82  A4D8     BTFSS STATUS, 2, ACCESS
0E84  D006     BRA 0xE92
991:           
992:                       ++*fmt;
0E86  C045     MOVFF fmt, FSR2
0E88  FFD9     NOP
0E8A  C046     MOVFF 0x46, FSR2H
0E8C  FFDA     NOP
0E8E  2ADE     INCF POSTINC2, F, ACCESS
0E90  D01C     BRA 0xECA
993:                       llu = (unsigned long long)va_arg(ap, unsigned int);
994:                                   
995:                       return otoa(fp, llu);
996:                   }
997:           
998:           #ifdef _VFPF_L
999:                   /* Long octal integer */
1000:                  if (!strncmp(*fmt, "lo", CSTRLEN("lo"))) {
1001:          
1002:                      *fmt += CSTRLEN("lo");
1003:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1004:                                  
1005:                      return otoa(fp, llu);
1006:                  }
1007:          #endif
1008:          
1009:          #ifdef _VFPF_LL
1010:                  /* Long long octal integer */
1011:                  if (!strncmp(*fmt, "llo", CSTRLEN("llo"))) {
1012:          
1013:                      *fmt += CSTRLEN("llo");
1014:                      llu = va_arg(ap, unsigned long long);
1015:                                  
1016:                      return otoa(fp, llu);
1017:                  }
1018:          #endif
1019:          
1020:          #ifdef _VFPF_J
1021:                  /* uintmax_t octal integer */
1022:                  if (!strncmp(*fmt, "jo", CSTRLEN("jo"))) {
1023:          
1024:                      *fmt += CSTRLEN("jo");
1025:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1026:                                  
1027:                      return otoa(fp, llu);
1028:                  }
1029:          #endif
1030:          
1031:          #ifdef _VFPF_T
1032:                  /* ptrdiff_t octal integer */
1033:                  if (!strncmp(*fmt, "to", CSTRLEN("to"))) {
1034:          
1035:                      *fmt += CSTRLEN("to");
1036:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1037:                                  
1038:                      return otoa(fp, llu);
1039:                  }
1040:          #endif
1041:          
1042:          #ifdef _VFPF_Z
1043:                  /* size_t octal integer */
1044:                  if (!strncmp(*fmt, "zo", CSTRLEN("zo"))) {
0E92  C045     MOVFF fmt, FSR2
0E94  FFD9     NOP
0E96  C046     MOVFF 0x46, FSR2H
0E98  FFDA     NOP
0E9A  CFDE     MOVFF POSTINC2, __pcstackCOMRAM
0E9C  F001     NOP
0E9E  CFDD     MOVFF POSTDEC2, 0x2
0EA0  F002     NOP
0EA2  0E3C     MOVLW 0x3C
0EA4  6E03     MOVWF fp, ACCESS
0EA6  0E08     MOVLW 0x8
0EA8  6E04     MOVWF data, ACCESS
0EAA  0E00     MOVLW 0x0
0EAC  6E06     MOVWF 0x6, ACCESS
0EAE  0E02     MOVLW 0x2
0EB0  6E05     MOVWF product, ACCESS
0EB2  ECB3     CALL 0x2566, 0
0EB4  F012     NOP
0EB6  5001     MOVF __pcstackCOMRAM, W, ACCESS
0EB8  1002     IORWF 0x2, W, ACCESS
0EBA  A4D8     BTFSS STATUS, 2, ACCESS
0EBC  D022     BRA 0xF02
1045:          
1046:                      *fmt += CSTRLEN("zo");
0EBE  0E02     MOVLW 0x2
0EC0  C045     MOVFF fmt, FSR2
0EC2  FFD9     NOP
0EC4  C046     MOVFF 0x46, FSR2H
0EC6  FFDA     NOP
0EC8  26DE     ADDWF POSTINC2, F, ACCESS
0ECA  0E00     MOVLW 0x0
0ECC  22DD     ADDWFC POSTDEC2, F, ACCESS
1047:                      llu = (unsigned long long)va_arg(ap, size_t);
0ECE  C047     MOVFF ap, FSR2
0ED0  FFD9     NOP
0ED2  C048     MOVFF 0x48, FSR2H
0ED4  FFDA     NOP
0ED6  CFDF     MOVFF INDF2, 0x49
0ED8  F049     NOP
0EDA  0E02     MOVLW 0x2
0EDC  26DE     ADDWF POSTINC2, F, ACCESS
0EDE  CFDF     MOVFF INDF2, 0x4A
0EE0  F04A     NOP
0EE2  0E00     MOVLW 0x0
0EE4  22DD     ADDWFC POSTDEC2, F, ACCESS
0EE6  C049     MOVFF 0x49, FSR2
0EE8  FFD9     NOP
0EEA  C04A     MOVFF 0x4A, FSR2H
0EEC  FFDA     NOP
0EEE  CFDE     MOVFF POSTINC2, 0x4B
0EF0  F04B     NOP
0EF2  CFDD     MOVFF POSTDEC2, 0x4C
0EF4  F04C     NOP
0EF6  C04B     MOVFF 0x4B, llu
0EF8  F073     NOP
0EFA  C04C     MOVFF 0x4C, 0x74
0EFC  F074     NOP
0EFE  0100     MOVLB 0x0
0F00  D77E     BRA 0xDFE
1048:                                  
1049:                      return otoa(fp, llu);
1050:                  }
1051:          #endif
1052:          #endif
1053:          
1054:                  /* Character count */
1055:          #ifdef _VFPF_N
1056:          
1057:          #ifdef _VFPF_HH
1058:                  if (!strncmp(*fmt, "hhn", CSTRLEN("hhn"))) {
0F02  C045     MOVFF fmt, FSR2
0F04  FFD9     NOP
0F06  C046     MOVFF 0x46, FSR2H
0F08  FFDA     NOP
0F0A  CFDE     MOVFF POSTINC2, __pcstackCOMRAM
0F0C  F001     NOP
0F0E  CFDD     MOVFF POSTDEC2, 0x2
0F10  F002     NOP
0F12  0E20     MOVLW 0x20
0F14  6E03     MOVWF fp, ACCESS
0F16  0E08     MOVLW 0x8
0F18  6E04     MOVWF data, ACCESS
0F1A  0E00     MOVLW 0x0
0F1C  6E06     MOVWF 0x6, ACCESS
0F1E  0E03     MOVLW 0x3
0F20  6E05     MOVWF product, ACCESS
0F22  ECB3     CALL 0x2566, 0
0F24  F012     NOP
0F26  5001     MOVF __pcstackCOMRAM, W, ACCESS
0F28  1002     IORWF 0x2, W, ACCESS
0F2A  A4D8     BTFSS STATUS, 2, ACCESS
0F2C  D027     BRA 0xF7C
1059:          
1060:                      *fmt += CSTRLEN("hhn");
0F2E  0E03     MOVLW 0x3
0F30  C045     MOVFF fmt, FSR2
0F32  FFD9     NOP
0F34  C046     MOVFF 0x46, FSR2H
0F36  FFDA     NOP
0F38  26DE     ADDWF POSTINC2, F, ACCESS
0F3A  0E00     MOVLW 0x0
0F3C  22DD     ADDWFC POSTDEC2, F, ACCESS
1061:                      vp = (void *)va_arg(ap, char *);
0F3E  C047     MOVFF ap, FSR2
0F40  FFD9     NOP
0F42  C048     MOVFF 0x48, FSR2H
0F44  FFDA     NOP
0F46  CFDF     MOVFF INDF2, 0x49
0F48  F049     NOP
0F4A  0E02     MOVLW 0x2
0F4C  26DE     ADDWF POSTINC2, F, ACCESS
0F4E  CFDF     MOVFF INDF2, 0x4A
0F50  F04A     NOP
0F52  0E00     MOVLW 0x0
0F54  22DD     ADDWFC POSTDEC2, F, ACCESS
0F56  C049     MOVFF 0x49, FSR2
0F58  FFD9     NOP
0F5A  C04A     MOVFF 0x4A, FSR2H
0F5C  FFDA     NOP
0F5E  CFDE     MOVFF POSTINC2, vp
0F60  F070     NOP
0F62  CFDD     MOVFF POSTDEC2, 0x71
0F64  F071     NOP
1062:                      *(char *)vp = (char)nout;
0F66  C070     MOVFF vp, FSR2
0F68  FFD9     NOP
0F6A  C071     MOVFF 0x71, FSR2H
0F6C  FFDA     NOP
0F6E  C0A0     MOVFF nout, INDF2
0F70  FFDF     NOP
1063:                      return 0;
0F72  0E00     MOVLW 0x0
0F74  6E44     MOVWF 0x44, ACCESS
0F76  0E00     MOVLW 0x0
0F78  6E43     MOVWF fp, ACCESS
0F7A  0012     RETURN 0
1064:                  }
1065:          #endif
1066:          
1067:          #ifdef _VFPF_H
1068:                  if (!strncmp(*fmt, "hn", CSTRLEN("hn"))) {
0F7C  C045     MOVFF fmt, FSR2
0F7E  FFD9     NOP
0F80  C046     MOVFF 0x46, FSR2H
0F82  FFDA     NOP
0F84  CFDE     MOVFF POSTINC2, __pcstackCOMRAM
0F86  F001     NOP
0F88  CFDD     MOVFF POSTDEC2, 0x2
0F8A  F002     NOP
0F8C  0E21     MOVLW 0x21
0F8E  6E03     MOVWF fp, ACCESS
0F90  0E08     MOVLW 0x8
0F92  6E04     MOVWF data, ACCESS
0F94  0E00     MOVLW 0x0
0F96  6E06     MOVWF 0x6, ACCESS
0F98  0E02     MOVLW 0x2
0F9A  6E05     MOVWF product, ACCESS
0F9C  ECB3     CALL 0x2566, 0
0F9E  F012     NOP
0FA0  5001     MOVF __pcstackCOMRAM, W, ACCESS
0FA2  1002     IORWF 0x2, W, ACCESS
0FA4  A4D8     BTFSS STATUS, 2, ACCESS
0FA6  D00A     BRA 0xFBC
1069:          
1070:                      *fmt += CSTRLEN("hn");
0FA8  D032     BRA 0x100E
1071:                      vp = (void *)va_arg(ap, short *);
1072:                      *(short *)vp = (short)nout;
0FAA  C070     MOVFF vp, FSR2
0FAC  FFD9     NOP
0FAE  C071     MOVFF 0x71, FSR2H
0FB0  FFDA     NOP
0FB2  C0A0     MOVFF nout, POSTINC2
0FB4  FFDE     NOP
0FB6  C0A1     MOVFF 0xA1, POSTDEC2
0FB8  FFDD     NOP
0FBA  D7DB     BRA 0xF72
1073:                      return 0;
1074:                  }
1075:          #endif
1076:          
1077:                  if (*fmt[0] == 'n') {
0FBC  C045     MOVFF fmt, FSR2
0FBE  FFD9     NOP
0FC0  C046     MOVFF 0x46, FSR2H
0FC2  FFDA     NOP
0FC4  CFDE     MOVFF POSTINC2, TBLPTR
0FC6  FFF6     NOP
0FC8  CFDD     MOVFF POSTDEC2, TBLPTRH
0FCA  FFF7     NOP
0FCC  0008     TBLRD*
0FCE  50F5     MOVF TABLAT, W, ACCESS
0FD0  0A6E     XORLW 0x6E
0FD2  A4D8     BTFSS STATUS, 2, ACCESS
0FD4  D006     BRA 0xFE2
1078:                      ++*fmt;
0FD6  C045     MOVFF fmt, FSR2
0FD8  FFD9     NOP
0FDA  C046     MOVFF 0x46, FSR2H
0FDC  FFDA     NOP
0FDE  2ADE     INCF POSTINC2, F, ACCESS
0FE0  D01C     BRA 0x101A
1079:                      vp = (void *)va_arg(ap, int *);
1080:                      *(int *)vp = nout;
1081:                      return 0;
1082:                  }
1083:          
1084:          #ifdef _VFPF_L
1085:                  if (!strncmp(*fmt, "ln", CSTRLEN("ln"))) {
1086:          
1087:                      *fmt += CSTRLEN("ln");
1088:                      vp = (void *)va_arg(ap, long *);
1089:                      *(long *)vp = (long)nout;
1090:                      return 0;
1091:                  }
1092:          #endif
1093:          
1094:          #ifdef _VFPF_LL
1095:                  if (!strncmp(*fmt, "lln", CSTRLEN("lln"))) {
1096:          
1097:                      *fmt += CSTRLEN("lln");
1098:                      vp = (void *)va_arg(ap, long long *);
1099:                      *(long long *)vp = (long long)nout;
1100:                      return 0;
1101:                  }
1102:          #endif
1103:          
1104:          #ifdef _VFPF_J
1105:                  if (!strncmp(*fmt, "jn", CSTRLEN("jn"))) {
1106:          
1107:                      *fmt += CSTRLEN("jn");
1108:                      vp = (void *)va_arg(ap, uintmax_t *);
1109:                      *(uintmax_t *)vp = (uintmax_t)nout;
1110:                      return 0;
1111:                  }
1112:          #endif
1113:          
1114:          #ifdef _VFPF_T
1115:                  if (!strncmp(*fmt, "tn", CSTRLEN("tn"))) {
1116:          
1117:                      *fmt += CSTRLEN("tn");
1118:                      vp = (void *)va_arg(ap, ptrdiff_t *);
1119:                      *(ptrdiff_t *)vp = (ptrdiff_t)nout;
1120:                      return 0;
1121:                  }
1122:          #endif
1123:          
1124:          #ifdef _VFPF_Z
1125:                  if (!strncmp(*fmt, "zn", CSTRLEN("zn"))) {
0FE2  C045     MOVFF fmt, FSR2
0FE4  FFD9     NOP
0FE6  C046     MOVFF 0x46, FSR2H
0FE8  FFDA     NOP
0FEA  CFDE     MOVFF POSTINC2, __pcstackCOMRAM
0FEC  F001     NOP
0FEE  CFDD     MOVFF POSTDEC2, 0x2
0FF0  F002     NOP
0FF2  0E39     MOVLW 0x39
0FF4  6E03     MOVWF fp, ACCESS
0FF6  0E08     MOVLW 0x8
0FF8  6E04     MOVWF data, ACCESS
0FFA  0E00     MOVLW 0x0
0FFC  6E06     MOVWF 0x6, ACCESS
0FFE  0E02     MOVLW 0x2
1000  6E05     MOVWF product, ACCESS
1002  ECB3     CALL 0x2566, 0
1004  F012     NOP
1006  5001     MOVF __pcstackCOMRAM, W, ACCESS
1008  1002     IORWF 0x2, W, ACCESS
100A  A4D8     BTFSS STATUS, 2, ACCESS
100C  D01D     BRA 0x1048
1126:          
1127:                      *fmt += CSTRLEN("zn");
100E  0E02     MOVLW 0x2
1010  C045     MOVFF fmt, FSR2
1012  FFD9     NOP
1014  C046     MOVFF 0x46, FSR2H
1016  FFDA     NOP
1018  26DE     ADDWF POSTINC2, F, ACCESS
101A  0E00     MOVLW 0x0
101C  22DD     ADDWFC POSTDEC2, F, ACCESS
1128:                      vp = (void *)va_arg(ap, size_t *);
101E  C047     MOVFF ap, FSR2
1020  FFD9     NOP
1022  C048     MOVFF 0x48, FSR2H
1024  FFDA     NOP
1026  CFDF     MOVFF INDF2, 0x49
1028  F049     NOP
102A  0E02     MOVLW 0x2
102C  26DE     ADDWF POSTINC2, F, ACCESS
102E  CFDF     MOVFF INDF2, 0x4A
1030  F04A     NOP
1032  0E00     MOVLW 0x0
1034  22DD     ADDWFC POSTDEC2, F, ACCESS
1036  C049     MOVFF 0x49, FSR2
1038  FFD9     NOP
103A  C04A     MOVFF 0x4A, FSR2H
103C  FFDA     NOP
103E  CFDE     MOVFF POSTINC2, vp
1040  F070     NOP
1042  CFDD     MOVFF POSTDEC2, 0x71
1044  F071     NOP
1129:                      *(size_t *)vp = (size_t)nout;
1046  D7B1     BRA 0xFAA
1130:                      return 0;
1131:                  }
1132:          #endif
1133:          
1134:          #endif
1135:          
1136:          #ifdef _VFPF_P
1137:                  /* Pointer */
1138:                  if (*fmt[0] == 'p') {
1048  C045     MOVFF fmt, FSR2
104A  FFD9     NOP
104C  C046     MOVFF 0x46, FSR2H
104E  FFDA     NOP
1050  CFDE     MOVFF POSTINC2, TBLPTR
1052  FFF6     NOP
1054  CFDD     MOVFF POSTDEC2, TBLPTRH
1056  FFF7     NOP
1058  0008     TBLRD*
105A  50F5     MOVF TABLAT, W, ACCESS
105C  0A70     XORLW 0x70
105E  A4D8     BTFSS STATUS, 2, ACCESS
1060  D043     BRA 0x10E8
1139:          
1140:                      ++*fmt;
1062  C045     MOVFF fmt, FSR2
1064  FFD9     NOP
1066  C046     MOVFF 0x46, FSR2H
1068  FFDA     NOP
106A  2ADE     INCF POSTINC2, F, ACCESS
106C  0E00     MOVLW 0x0
106E  22DD     ADDWFC POSTDEC2, F, ACCESS
1141:                      llu = (unsigned long long)(size_t)va_arg(ap, void *);
1070  C047     MOVFF ap, FSR2
1072  FFD9     NOP
1074  C048     MOVFF 0x48, FSR2H
1076  FFDA     NOP
1078  CFDF     MOVFF INDF2, 0x49
107A  F049     NOP
107C  0E02     MOVLW 0x2
107E  26DE     ADDWF POSTINC2, F, ACCESS
1080  CFDF     MOVFF INDF2, 0x4A
1082  F04A     NOP
1084  0E00     MOVLW 0x0
1086  22DD     ADDWFC POSTDEC2, F, ACCESS
1088  C049     MOVFF 0x49, FSR2
108A  FFD9     NOP
108C  C04A     MOVFF 0x4A, FSR2H
108E  FFDA     NOP
1090  CFDE     MOVFF POSTINC2, 0x4B
1092  F04B     NOP
1094  CFDD     MOVFF POSTDEC2, 0x4C
1096  F04C     NOP
1098  C04B     MOVFF 0x4B, llu
109A  F073     NOP
109C  C04C     MOVFF 0x4C, 0x74
109E  F074     NOP
10A0  0100     MOVLB 0x0
10A2  6B75     CLRF 0x75, BANKED
10A4  6B76     CLRF 0x76, BANKED
10A6  6B77     CLRF 0x77, BANKED
10A8  6B78     CLRF 0x78, BANKED
10AA  6B79     CLRF 0x79, BANKED
10AC  6B7A     CLRF 0x7A, BANKED
1142:                                  
1143:                      return xtoa(fp, llu, 'x');
10AE  C043     MOVFF fp, fp
10B0  F01C     NOP
10B2  C044     MOVFF 0x44, 0x1D
10B4  F01D     NOP
10B6  C073     MOVFF llu, d
10B8  F01E     NOP
10BA  C074     MOVFF 0x74, w
10BC  F01F     NOP
10BE  C075     MOVFF 0x75, 0x20
10C0  F020     NOP
10C2  C076     MOVFF 0x76, 0x21
10C4  F021     NOP
10C6  C077     MOVFF 0x77, 0x22
10C8  F022     NOP
10CA  C078     MOVFF 0x78, 0x23
10CC  F023     NOP
10CE  C079     MOVFF 0x79, 0x24
10D0  F024     NOP
10D2  C07A     MOVFF 0x7A, 0x25
10D4  F025     NOP
10D6  0E78     MOVLW 0x78
10D8  6E26     MOVWF x, ACCESS
10DA  EC01     CALL 0x1802, 0
10DC  F00C     NOP
10DE  C01C     MOVFF fp, fp
10E0  F043     NOP
10E2  C01D     MOVFF 0x1D, 0x44
10E4  F044     NOP
10E6  0012     RETURN 0
1144:                  }
1145:          #endif
1146:          
1147:          #ifdef _VFPF_S
1148:                  /* String */
1149:                  if (*fmt[0] == 's') {
10E8  C045     MOVFF fmt, FSR2
10EA  FFD9     NOP
10EC  C046     MOVFF 0x46, FSR2H
10EE  FFDA     NOP
10F0  CFDE     MOVFF POSTINC2, TBLPTR
10F2  FFF6     NOP
10F4  CFDD     MOVFF POSTDEC2, TBLPTRH
10F6  FFF7     NOP
10F8  0008     TBLRD*
10FA  50F5     MOVF TABLAT, W, ACCESS
10FC  0A73     XORLW 0x73
10FE  A4D8     BTFSS STATUS, 2, ACCESS
1100  D02A     BRA 0x1156
1150:          
1151:                      ++*fmt;
1102  C045     MOVFF fmt, FSR2
1104  FFD9     NOP
1106  C046     MOVFF 0x46, FSR2H
1108  FFDA     NOP
110A  2ADE     INCF POSTINC2, F, ACCESS
110C  0E00     MOVLW 0x0
110E  22DD     ADDWFC POSTDEC2, F, ACCESS
1152:                      cp = va_arg(ap, char *);
1110  C047     MOVFF ap, FSR2
1112  FFD9     NOP
1114  C048     MOVFF 0x48, FSR2H
1116  FFDA     NOP
1118  CFDF     MOVFF INDF2, 0x49
111A  F049     NOP
111C  0E02     MOVLW 0x2
111E  26DE     ADDWF POSTINC2, F, ACCESS
1120  CFDF     MOVFF INDF2, 0x4A
1122  F04A     NOP
1124  0E00     MOVLW 0x0
1126  22DD     ADDWFC POSTDEC2, F, ACCESS
1128  C049     MOVFF 0x49, FSR2
112A  FFD9     NOP
112C  C04A     MOVFF 0x4A, FSR2H
112E  FFDA     NOP
1130  CFDE     MOVFF POSTINC2, ttemp5
1132  F060     NOP
1134  CFDD     MOVFF POSTDEC2, 0x61
1136  F061     NOP
1153:          
1154:                      return stoa(fp, cp);
1138  C043     MOVFF fp, s
113A  F00A     NOP
113C  C044     MOVFF 0x44, csize
113E  F00B     NOP
1140  C060     MOVFF ttemp5, fp
1142  F00C     NOP
1144  C061     MOVFF 0x61, 0xD
1146  F00D     NOP
1148  ECF1     CALL 0x1FE2, 0
114A  F00F     NOP
114C  C00A     MOVFF s, fp
114E  F043     NOP
1150  C00B     MOVFF csize, 0x44
1152  F044     NOP
1154  0012     RETURN 0
1155:                  }
1156:          #endif
1157:          
1158:          #ifdef _VFPF_U
1159:          #ifdef _VFPF_HH
1160:                  /* Unsigned character decimal integer */
1161:                  if (!strncmp(*fmt, "hhu", CSTRLEN("hhu"))) {
1156  C045     MOVFF fmt, FSR2
1158  FFD9     NOP
115A  C046     MOVFF 0x46, FSR2H
115C  FFDA     NOP
115E  CFDE     MOVFF POSTINC2, __pcstackCOMRAM
1160  F001     NOP
1162  CFDD     MOVFF POSTDEC2, 0x2
1164  F002     NOP
1166  0E28     MOVLW 0x28
1168  6E03     MOVWF fp, ACCESS
116A  0E08     MOVLW 0x8
116C  6E04     MOVWF data, ACCESS
116E  0E00     MOVLW 0x0
1170  6E06     MOVWF 0x6, ACCESS
1172  0E03     MOVLW 0x3
1174  6E05     MOVWF product, ACCESS
1176  ECB3     CALL 0x2566, 0
1178  F012     NOP
117A  5001     MOVF __pcstackCOMRAM, W, ACCESS
117C  1002     IORWF 0x2, W, ACCESS
117E  A4D8     BTFSS STATUS, 2, ACCESS
1180  D03F     BRA 0x1200
1162:          
1163:                      *fmt += CSTRLEN("hhu");
1182  0E03     MOVLW 0x3
1184  C045     MOVFF fmt, FSR2
1186  FFD9     NOP
1188  C046     MOVFF 0x46, FSR2H
118A  FFDA     NOP
118C  26DE     ADDWF POSTINC2, F, ACCESS
118E  0E00     MOVLW 0x0
1190  22DD     ADDWFC POSTDEC2, F, ACCESS
1164:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1192  C047     MOVFF ap, FSR2
1194  FFD9     NOP
1196  C048     MOVFF 0x48, FSR2H
1198  FFDA     NOP
119A  CFDF     MOVFF INDF2, 0x49
119C  F049     NOP
119E  0E02     MOVLW 0x2
11A0  26DE     ADDWF POSTINC2, F, ACCESS
11A2  CFDF     MOVFF INDF2, 0x4A
11A4  F04A     NOP
11A6  0E00     MOVLW 0x0
11A8  22DD     ADDWFC POSTDEC2, F, ACCESS
11AA  C049     MOVFF 0x49, FSR2
11AC  FFD9     NOP
11AE  C04A     MOVFF 0x4A, FSR2H
11B0  FFDA     NOP
11B2  50DF     MOVF INDF2, W, ACCESS
11B4  6E4B     MOVWF 0x4B, ACCESS
11B6  504B     MOVF 0x4B, W, ACCESS
11B8  0100     MOVLB 0x0
11BA  6F73     MOVWF llu, BANKED
11BC  6B74     CLRF 0x74, BANKED
11BE  6B75     CLRF 0x75, BANKED
11C0  6B76     CLRF 0x76, BANKED
11C2  6B77     CLRF 0x77, BANKED
11C4  6B78     CLRF 0x78, BANKED
11C6  6B79     CLRF 0x79, BANKED
11C8  6B7A     CLRF 0x7A, BANKED
1165:                                  
1166:                      return utoa(fp, llu);
11CA  C043     MOVFF fp, fp
11CC  F01C     NOP
11CE  C044     MOVFF 0x44, 0x1D
11D0  F01D     NOP
11D2  C073     MOVFF llu, d
11D4  F01E     NOP
11D6  C074     MOVFF 0x74, w
11D8  F01F     NOP
11DA  C075     MOVFF 0x75, 0x20
11DC  F020     NOP
11DE  C076     MOVFF 0x76, 0x21
11E0  F021     NOP
11E2  C077     MOVFF 0x77, 0x22
11E4  F022     NOP
11E6  C078     MOVFF 0x78, 0x23
11E8  F023     NOP
11EA  C079     MOVFF 0x79, 0x24
11EC  F024     NOP
11EE  C07A     MOVFF 0x7A, 0x25
11F0  F025     NOP
11F2  EC17     CALL 0x1A2E, 0
11F4  F00D     NOP
11F6  C01C     MOVFF fp, fp
11F8  F043     NOP
11FA  C01D     MOVFF 0x1D, 0x44
11FC  F044     NOP
11FE  0012     RETURN 0
1167:                  }
1168:          #endif
1169:          
1170:          #ifdef _VFPF_H
1171:                  /* Unsigned short decimal integer */
1172:                  if (!strncmp(*fmt, "hu", CSTRLEN("hu"))) {
1200  C045     MOVFF fmt, FSR2
1202  FFD9     NOP
1204  C046     MOVFF 0x46, FSR2H
1206  FFDA     NOP
1208  CFDE     MOVFF POSTINC2, __pcstackCOMRAM
120A  F001     NOP
120C  CFDD     MOVFF POSTDEC2, 0x2
120E  F002     NOP
1210  0E29     MOVLW 0x29
1212  6E03     MOVWF fp, ACCESS
1214  0E08     MOVLW 0x8
1216  6E04     MOVWF data, ACCESS
1218  0E00     MOVLW 0x0
121A  6E06     MOVWF 0x6, ACCESS
121C  0E02     MOVLW 0x2
121E  6E05     MOVWF product, ACCESS
1220  ECB3     CALL 0x2566, 0
1222  F012     NOP
1224  5001     MOVF __pcstackCOMRAM, W, ACCESS
1226  1002     IORWF 0x2, W, ACCESS
1228  B4D8     BTFSC STATUS, 2, ACCESS
1173:          
1174:                      *fmt += CSTRLEN("hu");
122A  D029     BRA 0x127E
1175:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1176:                                  
1177:                      return utoa(fp, llu);
1178:                  }
1179:          #endif
1180:          
1181:                  /* Unsigned decimal integer */
1182:                  if (*fmt[0] == 'u') {
122C  C045     MOVFF fmt, FSR2
122E  FFD9     NOP
1230  C046     MOVFF 0x46, FSR2H
1232  FFDA     NOP
1234  CFDE     MOVFF POSTINC2, TBLPTR
1236  FFF6     NOP
1238  CFDD     MOVFF POSTDEC2, TBLPTRH
123A  FFF7     NOP
123C  0008     TBLRD*
123E  50F5     MOVF TABLAT, W, ACCESS
1240  0A75     XORLW 0x75
1242  A4D8     BTFSS STATUS, 2, ACCESS
1244  D006     BRA 0x1252
1183:          
1184:                      ++*fmt;
1246  C045     MOVFF fmt, FSR2
1248  FFD9     NOP
124A  C046     MOVFF 0x46, FSR2H
124C  FFDA     NOP
124E  2ADE     INCF POSTINC2, F, ACCESS
1250  D01C     BRA 0x128A
1185:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1186:                                  
1187:                      return utoa(fp, llu);
1188:                  }
1189:          
1190:          #ifdef _VFPF_L
1191:                  /* Unsigned long decimal integer */
1192:                  if (!strncmp(*fmt, "lu", CSTRLEN("lu"))) {
1193:          
1194:                      *fmt += CSTRLEN("lu");
1195:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1196:                                  
1197:                      return utoa(fp, llu);
1198:                  }
1199:          #endif
1200:          
1201:          #ifdef _VFPF_LL
1202:                  /* Unsigned long long decimal integer */
1203:                  if (!strncmp(*fmt, "llu", CSTRLEN("llu"))) {
1204:          
1205:                      *fmt += CSTRLEN("llu");
1206:                      llu = va_arg(ap, unsigned long long);
1207:                                  
1208:                      return utoa(fp, llu);
1209:                  }
1210:          #endif
1211:          
1212:          #ifdef _VFPF_J
1213:                  /* uintmax_t decimal integer */
1214:                  if (!strncmp(*fmt, "ju", CSTRLEN("ju"))) {
1215:          
1216:                      *fmt += CSTRLEN("ju");
1217:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1218:                                  
1219:                      return utoa(fp, llu);
1220:                  }
1221:          #endif
1222:          
1223:          #ifdef _VFPF_T
1224:                  /* ptrdiff_t decimal integer */
1225:                  if (!strncmp(*fmt, "tu", CSTRLEN("tu"))) {
1226:          
1227:                      *fmt += CSTRLEN("tu");
1228:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1229:                                  
1230:                      return utoa(fp, llu);
1231:                  }
1232:          #endif
1233:          
1234:          #ifdef _VFPF_Z
1235:                  /* size_t decimal integer */
1236:                  if (!strncmp(*fmt, "zu", CSTRLEN("zu"))) {
1252  C045     MOVFF fmt, FSR2
1254  FFD9     NOP
1256  C046     MOVFF 0x46, FSR2H
1258  FFDA     NOP
125A  CFDE     MOVFF POSTINC2, __pcstackCOMRAM
125C  F001     NOP
125E  CFDD     MOVFF POSTDEC2, 0x2
1260  F002     NOP
1262  0E3F     MOVLW 0x3F
1264  6E03     MOVWF fp, ACCESS
1266  0E08     MOVLW 0x8
1268  6E04     MOVWF data, ACCESS
126A  0E00     MOVLW 0x0
126C  6E06     MOVWF 0x6, ACCESS
126E  0E02     MOVLW 0x2
1270  6E05     MOVWF product, ACCESS
1272  ECB3     CALL 0x2566, 0
1274  F012     NOP
1276  5001     MOVF __pcstackCOMRAM, W, ACCESS
1278  1002     IORWF 0x2, W, ACCESS
127A  A4D8     BTFSS STATUS, 2, ACCESS
127C  D022     BRA 0x12C2
1237:          
1238:                      *fmt += CSTRLEN("zu");
127E  0E02     MOVLW 0x2
1280  C045     MOVFF fmt, FSR2
1282  FFD9     NOP
1284  C046     MOVFF 0x46, FSR2H
1286  FFDA     NOP
1288  26DE     ADDWF POSTINC2, F, ACCESS
128A  0E00     MOVLW 0x0
128C  22DD     ADDWFC POSTDEC2, F, ACCESS
1239:                      llu = (unsigned long long)va_arg(ap, size_t);
128E  C047     MOVFF ap, FSR2
1290  FFD9     NOP
1292  C048     MOVFF 0x48, FSR2H
1294  FFDA     NOP
1296  CFDF     MOVFF INDF2, 0x49
1298  F049     NOP
129A  0E02     MOVLW 0x2
129C  26DE     ADDWF POSTINC2, F, ACCESS
129E  CFDF     MOVFF INDF2, 0x4A
12A0  F04A     NOP
12A2  0E00     MOVLW 0x0
12A4  22DD     ADDWFC POSTDEC2, F, ACCESS
12A6  C049     MOVFF 0x49, FSR2
12A8  FFD9     NOP
12AA  C04A     MOVFF 0x4A, FSR2H
12AC  FFDA     NOP
12AE  CFDE     MOVFF POSTINC2, 0x4B
12B0  F04B     NOP
12B2  CFDD     MOVFF POSTDEC2, 0x4C
12B4  F04C     NOP
12B6  C04B     MOVFF 0x4B, llu
12B8  F073     NOP
12BA  C04C     MOVFF 0x4C, 0x74
12BC  F074     NOP
12BE  0100     MOVLB 0x0
12C0  D77E     BRA 0x11BE
1240:                                  
1241:                      return utoa(fp, llu);
1242:                  }
1243:          #endif
1244:          #endif
1245:          
1246:          #ifdef _VFPF_X
1247:          #ifdef _VFPF_HH
1248:                  /* Character hexadecimal integer */
1249:                  if (!strncmp(*fmt, "hhx", CSTRLEN("hhx")) || \
12C2  C045     MOVFF fmt, FSR2
12C4  FFD9     NOP
12C6  C046     MOVFF 0x46, FSR2H
12C8  FFDA     NOP
12CA  CFDE     MOVFF POSTINC2, __pcstackCOMRAM
12CC  F001     NOP
12CE  CFDD     MOVFF POSTDEC2, 0x2
12D0  F002     NOP
12D2  0E2C     MOVLW 0x2C
12D4  6E03     MOVWF fp, ACCESS
12D6  0E08     MOVLW 0x8
12D8  6E04     MOVWF data, ACCESS
12DA  0E00     MOVLW 0x0
12DC  6E06     MOVWF 0x6, ACCESS
12DE  0E03     MOVLW 0x3
12E0  6E05     MOVWF product, ACCESS
12E2  ECB3     CALL 0x2566, 0
12E4  F012     NOP
12E6  5001     MOVF __pcstackCOMRAM, W, ACCESS
12E8  1002     IORWF 0x2, W, ACCESS
12EA  B4D8     BTFSC STATUS, 2, ACCESS
12EC  D016     BRA 0x131A
12EE  C045     MOVFF fmt, FSR2
12F0  FFD9     NOP
12F2  C046     MOVFF 0x46, FSR2H
12F4  FFDA     NOP
12F6  CFDE     MOVFF POSTINC2, __pcstackCOMRAM
12F8  F001     NOP
12FA  CFDD     MOVFF POSTDEC2, 0x2
12FC  F002     NOP
12FE  0E14     MOVLW 0x14
1300  6E03     MOVWF fp, ACCESS
1302  0E08     MOVLW 0x8
1304  6E04     MOVWF data, ACCESS
1306  0E00     MOVLW 0x0
1308  6E06     MOVWF 0x6, ACCESS
130A  0E03     MOVLW 0x3
130C  6E05     MOVWF product, ACCESS
130E  ECB3     CALL 0x2566, 0
1310  F012     NOP
1312  5001     MOVF __pcstackCOMRAM, W, ACCESS
1314  1002     IORWF 0x2, W, ACCESS
1316  A4D8     BTFSS STATUS, 2, ACCESS
1318  D054     BRA 0x13C2
1250:                      !strncmp(*fmt, "hhX", CSTRLEN("hhX"))) {
1251:          
1252:                      c = (*fmt)[2];
131A  C045     MOVFF fmt, FSR2
131C  FFD9     NOP
131E  C046     MOVFF 0x46, FSR2H
1320  FFDA     NOP
1322  CFDE     MOVFF POSTINC2, 0x49
1324  F049     NOP
1326  CFDD     MOVFF POSTDEC2, 0x4A
1328  F04A     NOP
132A  0E02     MOVLW 0x2
132C  2649     ADDWF 0x49, F, ACCESS
132E  0E00     MOVLW 0x0
1330  224A     ADDWFC 0x4A, F, ACCESS
1332  C049     MOVFF 0x49, TBLPTR
1334  FFF6     NOP
1336  C04A     MOVFF 0x4A, TBLPTRH
1338  FFF7     NOP
133A  0008     TBLRD*
133C  CFF5     MOVFF TABLAT, c
133E  F072     NOP
1253:                      *fmt += CSTRLEN("hhx");
1340  0E03     MOVLW 0x3
1342  C045     MOVFF fmt, FSR2
1344  FFD9     NOP
1346  C046     MOVFF 0x46, FSR2H
1348  FFDA     NOP
134A  26DE     ADDWF POSTINC2, F, ACCESS
134C  0E00     MOVLW 0x0
134E  22DD     ADDWFC POSTDEC2, F, ACCESS
1254:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1350  C047     MOVFF ap, FSR2
1352  FFD9     NOP
1354  C048     MOVFF 0x48, FSR2H
1356  FFDA     NOP
1358  CFDF     MOVFF INDF2, 0x49
135A  F049     NOP
135C  0E02     MOVLW 0x2
135E  26DE     ADDWF POSTINC2, F, ACCESS
1360  CFDF     MOVFF INDF2, 0x4A
1362  F04A     NOP
1364  0E00     MOVLW 0x0
1366  22DD     ADDWFC POSTDEC2, F, ACCESS
1368  C049     MOVFF 0x49, FSR2
136A  FFD9     NOP
136C  C04A     MOVFF 0x4A, FSR2H
136E  FFDA     NOP
1370  50DF     MOVF INDF2, W, ACCESS
1372  6E4B     MOVWF 0x4B, ACCESS
1374  504B     MOVF 0x4B, W, ACCESS
1376  0100     MOVLB 0x0
1378  6F73     MOVWF llu, BANKED
137A  6B74     CLRF 0x74, BANKED
137C  6B75     CLRF 0x75, BANKED
137E  6B76     CLRF 0x76, BANKED
1380  6B77     CLRF 0x77, BANKED
1382  6B78     CLRF 0x78, BANKED
1384  6B79     CLRF 0x79, BANKED
1386  6B7A     CLRF 0x7A, BANKED
1255:                                  
1256:                      return xtoa(fp, llu, c);
1388  C043     MOVFF fp, fp
138A  F01C     NOP
138C  C044     MOVFF 0x44, 0x1D
138E  F01D     NOP
1390  C073     MOVFF llu, d
1392  F01E     NOP
1394  C074     MOVFF 0x74, w
1396  F01F     NOP
1398  C075     MOVFF 0x75, 0x20
139A  F020     NOP
139C  C076     MOVFF 0x76, 0x21
139E  F021     NOP
13A0  C077     MOVFF 0x77, 0x22
13A2  F022     NOP
13A4  C078     MOVFF 0x78, 0x23
13A6  F023     NOP
13A8  C079     MOVFF 0x79, 0x24
13AA  F024     NOP
13AC  C07A     MOVFF 0x7A, 0x25
13AE  F025     NOP
13B0  C072     MOVFF c, x
13B2  F026     NOP
13B4  EC01     CALL 0x1802, 0
13B6  F00C     NOP
13B8  C01C     MOVFF fp, fp
13BA  F043     NOP
13BC  C01D     MOVFF 0x1D, 0x44
13BE  F044     NOP
13C0  0012     RETURN 0
1257:                  }
1258:          #endif
1259:          
1260:          #ifdef _VFPF_H
1261:                  /* Short hexadecimal integer */
1262:                  if (!strncmp(*fmt, "hx", CSTRLEN("hx")) || \
13C2  C045     MOVFF fmt, FSR2
13C4  FFD9     NOP
13C6  C046     MOVFF 0x46, FSR2H
13C8  FFDA     NOP
13CA  CFDE     MOVFF POSTINC2, __pcstackCOMRAM
13CC  F001     NOP
13CE  CFDD     MOVFF POSTDEC2, 0x2
13D0  F002     NOP
13D2  0E2D     MOVLW 0x2D
13D4  6E03     MOVWF fp, ACCESS
13D6  0E08     MOVLW 0x8
13D8  6E04     MOVWF data, ACCESS
13DA  0E00     MOVLW 0x0
13DC  6E06     MOVWF 0x6, ACCESS
13DE  0E02     MOVLW 0x2
13E0  6E05     MOVWF product, ACCESS
13E2  ECB3     CALL 0x2566, 0
13E4  F012     NOP
13E6  5001     MOVF __pcstackCOMRAM, W, ACCESS
13E8  1002     IORWF 0x2, W, ACCESS
13EA  B4D8     BTFSC STATUS, 2, ACCESS
13EC  D088     BRA 0x14FE
13EE  C045     MOVFF fmt, FSR2
13F0  FFD9     NOP
13F2  C046     MOVFF 0x46, FSR2H
13F4  FFDA     NOP
13F6  CFDE     MOVFF POSTINC2, __pcstackCOMRAM
13F8  F001     NOP
13FA  CFDD     MOVFF POSTDEC2, 0x2
13FC  F002     NOP
13FE  0E15     MOVLW 0x15
1400  6E03     MOVWF fp, ACCESS
1402  0E08     MOVLW 0x8
1404  6E04     MOVWF data, ACCESS
1406  0E00     MOVLW 0x0
1408  6E06     MOVWF 0x6, ACCESS
140A  0E02     MOVLW 0x2
140C  6E05     MOVWF product, ACCESS
140E  ECB3     CALL 0x2566, 0
1410  F012     NOP
1412  5001     MOVF __pcstackCOMRAM, W, ACCESS
1414  1002     IORWF 0x2, W, ACCESS
1416  A4D8     BTFSS STATUS, 2, ACCESS
1418  D01B     BRA 0x1450
141A  D071     BRA 0x14FE
1263:                      !strncmp(*fmt, "hX", CSTRLEN("hX"))) {
1264:          
1265:                      c = (*fmt)[1];
1266:                      *fmt += CSTRLEN("hx");
1267:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
141C  C047     MOVFF ap, FSR2
141E  FFD9     NOP
1420  C048     MOVFF 0x48, FSR2H
1422  FFDA     NOP
1424  CFDF     MOVFF INDF2, 0x49
1426  F049     NOP
1428  0E02     MOVLW 0x2
142A  26DE     ADDWF POSTINC2, F, ACCESS
142C  CFDF     MOVFF INDF2, 0x4A
142E  F04A     NOP
1430  0E00     MOVLW 0x0
1432  22DD     ADDWFC POSTDEC2, F, ACCESS
1434  C049     MOVFF 0x49, FSR2
1436  FFD9     NOP
1438  C04A     MOVFF 0x4A, FSR2H
143A  FFDA     NOP
143C  CFDE     MOVFF POSTINC2, 0x4B
143E  F04B     NOP
1440  CFDD     MOVFF POSTDEC2, 0x4C
1442  F04C     NOP
1444  C04B     MOVFF 0x4B, llu
1446  F073     NOP
1448  C04C     MOVFF 0x4C, 0x74
144A  F074     NOP
144C  0100     MOVLB 0x0
144E  D796     BRA 0x137C
1268:                                  
1269:                      return xtoa(fp, llu, c);
1270:                  }
1271:          #endif
1272:          
1273:                  /* Hexadecimal integer */
1274:                  if ((*fmt[0] == 'x') || (*fmt[0] == 'X')) {
1450  C045     MOVFF fmt, FSR2
1452  FFD9     NOP
1454  C046     MOVFF 0x46, FSR2H
1456  FFDA     NOP
1458  CFDE     MOVFF POSTINC2, TBLPTR
145A  FFF6     NOP
145C  CFDD     MOVFF POSTDEC2, TBLPTRH
145E  FFF7     NOP
1460  0008     TBLRD*
1462  50F5     MOVF TABLAT, W, ACCESS
1464  0A78     XORLW 0x78
1466  B4D8     BTFSC STATUS, 2, ACCESS
1468  D00D     BRA 0x1484
146A  C045     MOVFF fmt, FSR2
146C  FFD9     NOP
146E  C046     MOVFF 0x46, FSR2H
1470  FFDA     NOP
1472  CFDE     MOVFF POSTINC2, TBLPTR
1474  FFF6     NOP
1476  CFDD     MOVFF POSTDEC2, TBLPTRH
1478  FFF7     NOP
147A  0008     TBLRD*
147C  50F5     MOVF TABLAT, W, ACCESS
147E  0A58     XORLW 0x58
1480  A4D8     BTFSS STATUS, 2, ACCESS
1482  D011     BRA 0x14A6
1275:          
1276:                      c = (*fmt)[0];
1484  C045     MOVFF fmt, FSR2
1486  FFD9     NOP
1488  C046     MOVFF 0x46, FSR2H
148A  FFDA     NOP
148C  CFDE     MOVFF POSTINC2, TBLPTR
148E  FFF6     NOP
1490  CFDD     MOVFF POSTDEC2, TBLPTRH
1492  FFF7     NOP
1494  0008     TBLRD*
1496  CFF5     MOVFF TABLAT, c
1498  F072     NOP
1277:                      ++*fmt;
149A  C045     MOVFF fmt, FSR2
149C  FFD9     NOP
149E  C046     MOVFF 0x46, FSR2H
14A0  FFDA     NOP
14A2  2ADE     INCF POSTINC2, F, ACCESS
14A4  D045     BRA 0x1530
1278:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1279:                                  
1280:                      return xtoa(fp, llu, c);
1281:                  }
1282:          
1283:          #ifdef _VFPF_L
1284:                  /* Long hexadecimal integer */
1285:                  if (!strncmp(*fmt, "lx", CSTRLEN("lx")) || \
1286:                      !strncmp(*fmt, "lX", CSTRLEN("lX"))) {
1287:          
1288:                      c = (*fmt)[1];
1289:                      *fmt += CSTRLEN("lx");
1290:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1291:                                  
1292:                      return xtoa(fp, llu, c);
1293:                  }
1294:          #endif
1295:          
1296:          #ifdef _VFPF_LL
1297:                  /* Long long hexadecimal integer */
1298:                  if (!strncmp(*fmt, "llx", CSTRLEN("llx")) || \
1299:                      !strncmp(*fmt, "llX", CSTRLEN("llX"))) {
1300:          
1301:                      c = (*fmt)[2];
1302:                      *fmt += CSTRLEN("llx");
1303:                      llu = va_arg(ap, unsigned long long);
1304:                                  
1305:                      return xtoa(fp, llu, c);
1306:                  }
1307:          #endif
1308:          
1309:          #ifdef _VFPF_J
1310:                  /* uintmax_t hexadecimal integer */
1311:                  if (!strncmp(*fmt, "jx", CSTRLEN("jx")) || \
1312:                      !strncmp(*fmt, "jX", CSTRLEN("jX"))) {
1313:          
1314:                      c = (*fmt)[1];
1315:                      *fmt += CSTRLEN("jx");
1316:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1317:                                  
1318:                      return xtoa(fp, llu, c);
1319:                  }
1320:          #endif
1321:          
1322:          #ifdef _VFPF_T
1323:                  /* ptrdiff_t hexadecimal integer */
1324:                  if (!strncmp(*fmt, "tx", CSTRLEN("tx")) || \
1325:                      !strncmp(*fmt, "tX", CSTRLEN("tX"))) {
1326:          
1327:                      c = (*fmt)[1];
1328:                      *fmt += CSTRLEN("tx");
1329:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1330:                                  
1331:                      return xtoa(fp, llu, c);
1332:                  }
1333:          #endif
1334:          
1335:          #ifdef _VFPF_Z
1336:                  /* size_t hexadecimal integer */
1337:                  if (!strncmp(*fmt, "zx", CSTRLEN("zx")) || \
14A6  C045     MOVFF fmt, FSR2
14A8  FFD9     NOP
14AA  C046     MOVFF 0x46, FSR2H
14AC  FFDA     NOP
14AE  CFDE     MOVFF POSTINC2, __pcstackCOMRAM
14B0  F001     NOP
14B2  CFDD     MOVFF POSTDEC2, 0x2
14B4  F002     NOP
14B6  0E42     MOVLW 0x42
14B8  6E03     MOVWF fp, ACCESS
14BA  0E08     MOVLW 0x8
14BC  6E04     MOVWF data, ACCESS
14BE  0E00     MOVLW 0x0
14C0  6E06     MOVWF 0x6, ACCESS
14C2  0E02     MOVLW 0x2
14C4  6E05     MOVWF product, ACCESS
14C6  ECB3     CALL 0x2566, 0
14C8  F012     NOP
14CA  5001     MOVF __pcstackCOMRAM, W, ACCESS
14CC  1002     IORWF 0x2, W, ACCESS
14CE  B4D8     BTFSC STATUS, 2, ACCESS
14D0  D016     BRA 0x14FE
14D2  C045     MOVFF fmt, FSR2
14D4  FFD9     NOP
14D6  C046     MOVFF 0x46, FSR2H
14D8  FFDA     NOP
14DA  CFDE     MOVFF POSTINC2, __pcstackCOMRAM
14DC  F001     NOP
14DE  CFDD     MOVFF POSTDEC2, 0x2
14E0  F002     NOP
14E2  0E30     MOVLW 0x30
14E4  6E03     MOVWF fp, ACCESS
14E6  0E08     MOVLW 0x8
14E8  6E04     MOVWF data, ACCESS
14EA  0E00     MOVLW 0x0
14EC  6E06     MOVWF 0x6, ACCESS
14EE  0E02     MOVLW 0x2
14F0  6E05     MOVWF product, ACCESS
14F2  ECB3     CALL 0x2566, 0
14F4  F012     NOP
14F6  5001     MOVF __pcstackCOMRAM, W, ACCESS
14F8  1002     IORWF 0x2, W, ACCESS
14FA  A4D8     BTFSS STATUS, 2, ACCESS
14FC  D01C     BRA 0x1536
1338:                      !strncmp(*fmt, "zX", CSTRLEN("zX"))) {
1339:          
1340:                      c = (*fmt)[1];
14FE  C045     MOVFF fmt, FSR2
1500  FFD9     NOP
1502  C046     MOVFF 0x46, FSR2H
1504  FFDA     NOP
1506  CFDE     MOVFF POSTINC2, 0x49
1508  F049     NOP
150A  CFDD     MOVFF POSTDEC2, 0x4A
150C  F04A     NOP
150E  0E01     MOVLW 0x1
1510  2649     ADDWF 0x49, F, ACCESS
1512  0E00     MOVLW 0x0
1514  224A     ADDWFC 0x4A, F, ACCESS
1516  C049     MOVFF 0x49, TBLPTR
1518  FFF6     NOP
151A  C04A     MOVFF 0x4A, TBLPTRH
151C  FFF7     NOP
151E  0008     TBLRD*
1520  CFF5     MOVFF TABLAT, c
1522  F072     NOP
1341:                      *fmt += CSTRLEN("zx");
1524  0E02     MOVLW 0x2
1526  C045     MOVFF fmt, FSR2
1528  FFD9     NOP
152A  C046     MOVFF 0x46, FSR2H
152C  FFDA     NOP
152E  26DE     ADDWF POSTINC2, F, ACCESS
1530  0E00     MOVLW 0x0
1532  22DD     ADDWFC POSTDEC2, F, ACCESS
1342:                      llu = (unsigned long long)va_arg(ap, size_t);
1534  D773     BRA 0x141C
1343:                                  
1344:                      return xtoa(fp, llu, c);
1345:                  }
1346:          #endif
1347:          #endif
1348:          
1349:                  /* 'Escaped' '%' character */
1350:                  if ((*fmt)[0] == '%') {
1536  C045     MOVFF fmt, FSR2
1538  FFD9     NOP
153A  C046     MOVFF 0x46, FSR2H
153C  FFDA     NOP
153E  CFDE     MOVFF POSTINC2, TBLPTR
1540  FFF6     NOP
1542  CFDD     MOVFF POSTDEC2, TBLPTRH
1544  FFF7     NOP
1546  0008     TBLRD*
1548  50F5     MOVF TABLAT, W, ACCESS
154A  0A25     XORLW 0x25
154C  A4D8     BTFSS STATUS, 2, ACCESS
154E  D016     BRA 0x157C
1351:                      ++*fmt;
1550  C045     MOVFF fmt, FSR2
1552  FFD9     NOP
1554  C046     MOVFF 0x46, FSR2H
1556  FFDA     NOP
1558  2ADE     INCF POSTINC2, F, ACCESS
155A  0E00     MOVLW 0x0
155C  22DD     ADDWFC POSTDEC2, F, ACCESS
1352:                      fputc((int)'%', fp);
155E  0E00     MOVLW 0x0
1560  6E02     MOVWF 0x2, ACCESS
1562  0E25     MOVLW 0x25
1564  6E01     MOVWF __pcstackCOMRAM, ACCESS
1566  C043     MOVFF fp, fp
1568  F003     NOP
156A  C044     MOVFF 0x44, data
156C  F004     NOP
156E  EC5C     CALL 0x26B8, 0
1570  F013     NOP
1353:                      return 1;
1572  0E00     MOVLW 0x0
1574  6E44     MOVWF 0x44, ACCESS
1576  0E01     MOVLW 0x1
1578  6E43     MOVWF fp, ACCESS
157A  0012     RETURN 0
1354:                  }
1355:          
1356:                  /* Unrecognized conversion */
1357:                  ++*fmt;
157C  C045     MOVFF fmt, FSR2
157E  FFD9     NOP
1580  C046     MOVFF 0x46, FSR2H
1582  FFDA     NOP
1584  2ADE     INCF POSTINC2, F, ACCESS
1586  0E00     MOVLW 0x0
1588  22DD     ADDWFC POSTDEC2, F, ACCESS
158A  D4F3     BRA 0xF72
1358:                  return 0;
1359:              }
1360:          
1361:              /* No conversion, just intervening text */
1362:              fputc((int)(*fmt)[0], fp);
158C  C045     MOVFF fmt, FSR2
158E  FFD9     NOP
1590  C046     MOVFF 0x46, FSR2H
1592  FFDA     NOP
1594  CFDE     MOVFF POSTINC2, TBLPTR
1596  FFF6     NOP
1598  CFDD     MOVFF POSTDEC2, TBLPTRH
159A  FFF7     NOP
159C  0008     TBLRD*
159E  50F5     MOVF TABLAT, W, ACCESS
15A0  6E01     MOVWF __pcstackCOMRAM, ACCESS
15A2  6A02     CLRF 0x2, ACCESS
15A4  C043     MOVFF fp, fp
15A6  F003     NOP
15A8  C044     MOVFF 0x44, data
15AA  F004     NOP
15AC  EC5C     CALL 0x26B8, 0
15AE  F013     NOP
1363:              ++*fmt;
15B0  C045     MOVFF fmt, FSR2
15B2  FFD9     NOP
15B4  C046     MOVFF 0x46, FSR2H
15B6  FFDA     NOP
15B8  2ADE     INCF POSTINC2, F, ACCESS
15BA  0E00     MOVLW 0x0
15BC  22DD     ADDWFC POSTDEC2, F, ACCESS
15BE  D7D9     BRA 0x1572
1364:              return 1;
1365:          }
1366:          #endif
1367:          
1368:          int vfprintf(FILE *fp, const char *fmt, va_list ap)
1369:          {
1370:          #ifdef _VFPF_CONVERT
1371:              char *cfmt;
1372:          
1373:              cfmt = (char *)fmt;
27EE  C04F     MOVFF fmt, cfmt
27F0  F053     NOP
27F2  C050     MOVFF 0x50, 0x54
27F4  F054     NOP
1374:              nout = 0;
27F6  0E00     MOVLW 0x0
27F8  0100     MOVLB 0x0
27FA  6FA1     MOVWF 0xA1, BANKED
27FC  0E00     MOVLW 0x0
27FE  6FA0     MOVWF nout, BANKED
1375:              while (*cfmt) {
2800  D013     BRA 0x2828
2828  C053     MOVFF cfmt, TBLPTR
282A  FFF6     NOP
282C  C054     MOVFF 0x54, TBLPTRH
282E  FFF7     NOP
2830  0008     TBLRD*
2832  50F5     MOVF TABLAT, W, ACCESS
2834  0900     IORLW 0x0
2836  A4D8     BTFSS STATUS, 2, ACCESS
2838  D7E4     BRA 0x2802
1376:                  nout += vfpfcnvrt(fp, &cfmt, ap);
2802  C04D     MOVFF fp, fp
2804  F043     NOP
2806  C04E     MOVFF 0x4E, 0x44
2808  F044     NOP
280A  0E53     MOVLW 0x53
280C  6E45     MOVWF fmt, ACCESS
280E  0E00     MOVLW 0x0
2810  6E46     MOVWF 0x46, ACCESS
2812  C051     MOVFF ap, ap
2814  F047     NOP
2816  C052     MOVFF 0x52, 0x48
2818  F048     NOP
281A  EC25     CALL 0x84A, 0
281C  F004     NOP
281E  5043     MOVF fp, W, ACCESS
2820  0100     MOVLB 0x0
2822  27A0     ADDWF nout, F, BANKED
2824  5044     MOVF 0x44, W, ACCESS
2826  23A1     ADDWFC 0xA1, F, BANKED
1377:              }
1378:              return nout;
283A  C0A0     MOVFF nout, fp
283C  F04D     NOP
283E  C0A1     MOVFF 0xA1, 0x4E
2840  F04E     NOP
1379:          #else
1380:              return fputs(fmt, fp);
1381:          #endif
1382:          }
2842  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/atoi.c  --------------------------
1:             #include <stdlib.h>
2:             #include <ctype.h>
3:             
4:             int atoi(const char *s)
5:             {
6:             	int n=0, neg=0;
1EA2  0E00     MOVLW 0x0
1EA4  6E16     MOVWF i, ACCESS
1EA6  0E00     MOVLW 0x0
1EA8  6E15     MOVWF p, ACCESS
1EAA  0E00     MOVLW 0x0
1EAC  6E0F     MOVWF i, ACCESS
1EAE  0E00     MOVLW 0x0
1EB0  6E0E     MOVWF c, ACCESS
7:             	while (isspace(*s)) s++;
1EB2  D002     BRA 0x1EB8
1EB4  4A08     INFSNZ s, F, ACCESS
1EB6  2A09     INCF divisor, F, ACCESS
1EB8  0E01     MOVLW 0x1
1EBA  6E14     MOVWF 0x14, ACCESS
1EBC  C008     MOVFF s, TBLPTR
1EBE  FFF6     NOP
1EC0  C009     MOVFF divisor, TBLPTRH
1EC2  FFF7     NOP
1EC4  0008     TBLRD*
1EC6  50F5     MOVF TABLAT, W, ACCESS
1EC8  0A20     XORLW 0x20
1ECA  B4D8     BTFSC STATUS, 2, ACCESS
1ECC  D018     BRA 0x1EFE
1ECE  0EF7     MOVLW 0xF7
1ED0  6E0A     MOVWF s, ACCESS
1ED2  0EFF     MOVLW 0xFF
1ED4  6E0B     MOVWF csize, ACCESS
1ED6  C008     MOVFF s, TBLPTR
1ED8  FFF6     NOP
1EDA  C009     MOVFF divisor, TBLPTRH
1EDC  FFF7     NOP
1EDE  0008     TBLRD*
1EE0  50F5     MOVF TABLAT, W, ACCESS
1EE2  6E0C     MOVWF fp, ACCESS
1EE4  6A0D     CLRF 0xD, ACCESS
1EE6  500A     MOVF s, W, ACCESS
1EE8  260C     ADDWF fp, F, ACCESS
1EEA  500B     MOVF csize, W, ACCESS
1EEC  220D     ADDWFC 0xD, F, ACCESS
1EEE  500D     MOVF 0xD, W, ACCESS
1EF0  E104     BNZ 0x1EFA
1EF2  0E05     MOVLW 0x5
1EF4  5C0C     SUBWF fp, W, ACCESS
1EF6  A0D8     BTFSS STATUS, 0, ACCESS
1EF8  D002     BRA 0x1EFE
1EFA  0E00     MOVLW 0x0
1EFC  6E14     MOVWF 0x14, ACCESS
1EFE  C014     MOVFF 0x14, 0x10
1F00  F010     NOP
1F02  6A11     CLRF counter, ACCESS
1F04  5010     MOVF 0x10, W, ACCESS
1F06  1011     IORWF counter, W, ACCESS
1F08  B4D8     BTFSC STATUS, 2, ACCESS
1F0A  D008     BRA 0x1F1C
1F0C  D7D3     BRA 0x1EB4
8:             	switch (*s) {
9:             	case '-': neg=1;
1F0E  0E00     MOVLW 0x0
1F10  6E0F     MOVWF i, ACCESS
1F12  0E01     MOVLW 0x1
1F14  6E0E     MOVWF c, ACCESS
10:            	case '+': s++;
1F16  4A08     INFSNZ s, F, ACCESS
1F18  2A09     INCF divisor, F, ACCESS
11:            	}
1F1A  D02E     BRA 0x1F78
1F1C  C008     MOVFF s, TBLPTR
1F1E  FFF6     NOP
1F20  C009     MOVFF divisor, TBLPTRH
1F22  FFF7     NOP
1F24  0008     TBLRD*
1F26  50F5     MOVF TABLAT, W, ACCESS
1F28  6E0A     MOVWF s, ACCESS
1F2A  6A0B     CLRF csize, ACCESS
1F2C  500B     MOVF csize, W, ACCESS
1F2E  0A00     XORLW 0x0
1F30  A4D8     BTFSS STATUS, 2, ACCESS
1F32  D022     BRA 0x1F78
1F34  500A     MOVF s, W, ACCESS
1F36  0A2B     XORLW 0x2B
1F38  B4D8     BTFSC STATUS, 2, ACCESS
1F3A  D7ED     BRA 0x1F16
1F3C  0A06     XORLW 0x6
1F3E  B4D8     BTFSC STATUS, 2, ACCESS
1F40  D7E6     BRA 0x1F0E
1F42  D01A     BRA 0x1F78
12:            	/* Compute n as a negative number to avoid overflow on INT_MIN */
13:            	while (isdigit(*s))
1F78  0ED0     MOVLW 0xD0
1F7A  6E0A     MOVWF s, ACCESS
1F7C  0EFF     MOVLW 0xFF
1F7E  6E0B     MOVWF csize, ACCESS
1F80  C008     MOVFF s, TBLPTR
1F82  FFF6     NOP
1F84  C009     MOVFF divisor, TBLPTRH
1F86  FFF7     NOP
1F88  0008     TBLRD*
1F8A  50F5     MOVF TABLAT, W, ACCESS
1F8C  6E0C     MOVWF fp, ACCESS
1F8E  6A0D     CLRF 0xD, ACCESS
1F90  500A     MOVF s, W, ACCESS
1F92  260C     ADDWF fp, F, ACCESS
1F94  500B     MOVF csize, W, ACCESS
1F96  220D     ADDWFC 0xD, F, ACCESS
1F98  500D     MOVF 0xD, W, ACCESS
1F9A  E106     BNZ 0x1FA8
1F9C  0E0A     MOVLW 0xA
1F9E  5C0C     SUBWF fp, W, ACCESS
1FA0  B0D8     BTFSC STATUS, 0, ACCESS
1FA2  D002     BRA 0x1FA8
1FA4  0E01     MOVLW 0x1
1FA6  D001     BRA 0x1FAA
1FA8  0E00     MOVLW 0x0
1FAA  6E12     MOVWF sign, ACCESS
1FAC  6A13     CLRF quotient, ACCESS
1FAE  5012     MOVF sign, W, ACCESS
1FB0  1013     IORWF quotient, W, ACCESS
1FB2  A4D8     BTFSS STATUS, 2, ACCESS
1FB4  D7C7     BRA 0x1F44
14:            		n = 10*n - (*s++ - '0');
1F44  C015     MOVFF p, __pcstackCOMRAM
1F46  F001     NOP
1F48  C016     MOVFF i, 0x2
1F4A  F002     NOP
1F4C  0E00     MOVLW 0x0
1F4E  6E04     MOVWF data, ACCESS
1F50  0E0A     MOVLW 0xA
1F52  6E03     MOVWF fp, ACCESS
1F54  ECAE     CALL 0x2B5C, 0
1F56  F015     NOP
1F58  C008     MOVFF s, TBLPTR
1F5A  FFF6     NOP
1F5C  C009     MOVFF divisor, TBLPTRH
1F5E  FFF7     NOP
1F60  0008     TBLRD*
1F62  50F5     MOVF TABLAT, W, ACCESS
1F64  5E01     SUBWF __pcstackCOMRAM, F, ACCESS
1F66  0E00     MOVLW 0x0
1F68  5A02     SUBWFB 0x2, F, ACCESS
1F6A  0E30     MOVLW 0x30
1F6C  2401     ADDWF __pcstackCOMRAM, W, ACCESS
1F6E  6E15     MOVWF p, ACCESS
1F70  0E00     MOVLW 0x0
1F72  2002     ADDWFC 0x2, W, ACCESS
1F74  6E16     MOVWF i, ACCESS
1F76  D7CF     BRA 0x1F16
15:            	return neg ? n : -n;
1FB6  500E     MOVF c, W, ACCESS
1FB8  100F     IORWF i, W, ACCESS
1FBA  A4D8     BTFSS STATUS, 2, ACCESS
1FBC  D00D     BRA 0x1FD8
1FBE  C015     MOVFF p, s
1FC0  F00A     NOP
1FC2  C016     MOVFF i, csize
1FC4  F00B     NOP
1FC6  1E0A     COMF s, F, ACCESS
1FC8  1E0B     COMF csize, F, ACCESS
1FCA  4A0A     INFSNZ s, F, ACCESS
1FCC  2A0B     INCF csize, F, ACCESS
1FCE  C00A     MOVFF s, s
1FD0  F008     NOP
1FD2  C00B     MOVFF csize, divisor
1FD4  F009     NOP
1FD6  0012     RETURN 0
1FD8  C015     MOVFF p, s
1FDA  F008     NOP
1FDC  C016     MOVFF i, divisor
1FDE  F009     NOP
16:            }
1FE0  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/aomod.c  -------------------------
1:             // long long signed unsigned modulus
2:             
3:             #pragma warning disable 1516
4:             
5:             signed long long int
6:             #ifdef __PICC__
7:             __aomod(signed long long int divisor, signed long long int dividend)
8:             #else
9:             __aomod(signed long long int dividend, signed long long int divisor)
10:            #endif
11:            {
12:            	unsigned char	counter, sign;
13:            
14:            	sign = 0;
210A  0E00     MOVLW 0x0
210C  6E12     MOVWF sign, ACCESS
15:            	if(dividend < 0) {
210E  AE08     BTFSS s, 7, ACCESS
2110  D012     BRA 0x2136
16:            		dividend = -dividend;
2112  1E08     COMF s, F, ACCESS
2114  1E07     COMF c, F, ACCESS
2116  1E06     COMF 0x6, F, ACCESS
2118  1E05     COMF product, F, ACCESS
211A  1E04     COMF data, F, ACCESS
211C  1E03     COMF fp, F, ACCESS
211E  1E02     COMF 0x2, F, ACCESS
2120  6C01     NEGF __pcstackCOMRAM, ACCESS
2122  0E00     MOVLW 0x0
2124  2202     ADDWFC 0x2, F, ACCESS
2126  2203     ADDWFC fp, F, ACCESS
2128  2204     ADDWFC data, F, ACCESS
212A  2205     ADDWFC product, F, ACCESS
212C  2206     ADDWFC 0x6, F, ACCESS
212E  2207     ADDWFC c, F, ACCESS
2130  2208     ADDWFC s, F, ACCESS
17:            		sign = 1;
2132  0E01     MOVLW 0x1
2134  6E12     MOVWF sign, ACCESS
18:            	}
19:            	if(divisor < 0)
2136  AE10     BTFSS 0x10, 7, ACCESS
2138  D010     BRA 0x215A
20:            		divisor = -divisor;
213A  1E10     COMF 0x10, F, ACCESS
213C  1E0F     COMF i, F, ACCESS
213E  1E0E     COMF c, F, ACCESS
2140  1E0D     COMF 0xD, F, ACCESS
2142  1E0C     COMF fp, F, ACCESS
2144  1E0B     COMF csize, F, ACCESS
2146  1E0A     COMF s, F, ACCESS
2148  6C09     NEGF divisor, ACCESS
214A  0E00     MOVLW 0x0
214C  220A     ADDWFC s, F, ACCESS
214E  220B     ADDWFC csize, F, ACCESS
2150  220C     ADDWFC fp, F, ACCESS
2152  220D     ADDWFC 0xD, F, ACCESS
2154  220E     ADDWFC c, F, ACCESS
2156  220F     ADDWFC i, F, ACCESS
2158  2210     ADDWFC 0x10, F, ACCESS
21:            	if(divisor != 0) {
215A  5009     MOVF divisor, W, ACCESS
215C  100A     IORWF s, W, ACCESS
215E  100B     IORWF csize, W, ACCESS
2160  100C     IORWF fp, W, ACCESS
2162  100D     IORWF 0xD, W, ACCESS
2164  100E     IORWF c, W, ACCESS
2166  100F     IORWF i, W, ACCESS
2168  1010     IORWF 0x10, W, ACCESS
216A  B4D8     BTFSC STATUS, 2, ACCESS
216C  D03C     BRA 0x21E6
22:            		counter = 1;
216E  0E01     MOVLW 0x1
2170  6E11     MOVWF counter, ACCESS
23:            		while((divisor & 0x8000000000000000ULL) == 0) {
2172  D00A     BRA 0x2188
2188  AE10     BTFSS 0x10, 7, ACCESS
218A  D7F4     BRA 0x2174
24:            			divisor <<= 1;
2174  90D8     BCF STATUS, 0, ACCESS
2176  3609     RLCF divisor, F, ACCESS
2178  360A     RLCF s, F, ACCESS
217A  360B     RLCF csize, F, ACCESS
217C  360C     RLCF fp, F, ACCESS
217E  360D     RLCF 0xD, F, ACCESS
2180  360E     RLCF c, F, ACCESS
2182  360F     RLCF i, F, ACCESS
2184  3610     RLCF 0x10, F, ACCESS
25:            			counter++;
2186  2A11     INCF counter, F, ACCESS
26:            		}
27:            		do {
28:            			if((unsigned long long)divisor <= (unsigned long long)dividend)
218C  5009     MOVF divisor, W, ACCESS
218E  5C01     SUBWF __pcstackCOMRAM, W, ACCESS
2190  500A     MOVF s, W, ACCESS
2192  5802     SUBWFB 0x2, W, ACCESS
2194  500B     MOVF csize, W, ACCESS
2196  5803     SUBWFB fp, W, ACCESS
2198  500C     MOVF fp, W, ACCESS
219A  5804     SUBWFB data, W, ACCESS
219C  500D     MOVF 0xD, W, ACCESS
219E  5805     SUBWFB product, W, ACCESS
21A0  500E     MOVF c, W, ACCESS
21A2  5806     SUBWFB 0x6, W, ACCESS
21A4  500F     MOVF i, W, ACCESS
21A6  5807     SUBWFB c, W, ACCESS
21A8  5010     MOVF 0x10, W, ACCESS
21AA  5808     SUBWFB s, W, ACCESS
21AC  A0D8     BTFSS STATUS, 0, ACCESS
21AE  D010     BRA 0x21D0
29:            				dividend -= divisor;
21B0  5009     MOVF divisor, W, ACCESS
21B2  5E01     SUBWF __pcstackCOMRAM, F, ACCESS
21B4  500A     MOVF s, W, ACCESS
21B6  5A02     SUBWFB 0x2, F, ACCESS
21B8  500B     MOVF csize, W, ACCESS
21BA  5A03     SUBWFB fp, F, ACCESS
21BC  500C     MOVF fp, W, ACCESS
21BE  5A04     SUBWFB data, F, ACCESS
21C0  500D     MOVF 0xD, W, ACCESS
21C2  5A05     SUBWFB product, F, ACCESS
21C4  500E     MOVF c, W, ACCESS
21C6  5A06     SUBWFB 0x6, F, ACCESS
21C8  500F     MOVF i, W, ACCESS
21CA  5A07     SUBWFB c, F, ACCESS
21CC  5010     MOVF 0x10, W, ACCESS
21CE  5A08     SUBWFB s, F, ACCESS
30:            			*(unsigned long long int *)&divisor >>= 1;
21D0  90D8     BCF STATUS, 0, ACCESS
21D2  3210     RRCF 0x10, F, ACCESS
21D4  320F     RRCF i, F, ACCESS
21D6  320E     RRCF c, F, ACCESS
21D8  320D     RRCF 0xD, F, ACCESS
21DA  320C     RRCF fp, F, ACCESS
21DC  320B     RRCF csize, F, ACCESS
21DE  320A     RRCF s, F, ACCESS
21E0  3209     RRCF divisor, F, ACCESS
31:            		} while(--counter != 0);
21E2  2E11     DECFSZ counter, F, ACCESS
21E4  D7D3     BRA 0x218C
32:            	}
33:            	if(sign)
21E6  5012     MOVF sign, W, ACCESS
21E8  B4D8     BTFSC STATUS, 2, ACCESS
21EA  D010     BRA 0x220C
34:            		dividend = -dividend;
21EC  1E08     COMF s, F, ACCESS
21EE  1E07     COMF c, F, ACCESS
21F0  1E06     COMF 0x6, F, ACCESS
21F2  1E05     COMF product, F, ACCESS
21F4  1E04     COMF data, F, ACCESS
21F6  1E03     COMF fp, F, ACCESS
21F8  1E02     COMF 0x2, F, ACCESS
21FA  6C01     NEGF __pcstackCOMRAM, ACCESS
21FC  0E00     MOVLW 0x0
21FE  2202     ADDWFC 0x2, F, ACCESS
2200  2203     ADDWFC fp, F, ACCESS
2202  2204     ADDWFC data, F, ACCESS
2204  2205     ADDWFC product, F, ACCESS
2206  2206     ADDWFC 0x6, F, ACCESS
2208  2207     ADDWFC c, F, ACCESS
220A  2208     ADDWFC s, F, ACCESS
35:            	return dividend;
220C  C001     MOVFF __pcstackCOMRAM, __pcstackCOMRAM
220E  F001     NOP
2210  C002     MOVFF 0x2, 0x2
2212  F002     NOP
2214  C003     MOVFF fp, fp
2216  F003     NOP
2218  C004     MOVFF data, data
221A  F004     NOP
221C  C005     MOVFF product, product
221E  F005     NOP
2220  C006     MOVFF 0x6, 0x6
2222  F006     NOP
2224  C007     MOVFF c, c
2226  F007     NOP
2228  C008     MOVFF s, s
222A  F008     NOP
36:            }
222C  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/aodiv.c  -------------------------
1:             // long long signed unsigned division
2:             
3:             #pragma warning disable 1516
4:             
5:             signed long long int
6:             #ifdef __PICC__
7:             __aodiv(signed long long int divisor, signed long long int dividend)
8:             #else
9:             __aodiv(signed long long int dividend, signed long long int divisor)
10:            #endif
11:            {
12:            	signed long long int	quotient;
13:            	unsigned char	counter, sign;
14:            
15:            	sign = 0;
1D5A  0E00     MOVLW 0x0
1D5C  6E12     MOVWF sign, ACCESS
16:            	if(divisor < 0) {
1D5E  AE10     BTFSS 0x10, 7, ACCESS
1D60  D012     BRA 0x1D86
17:            		divisor = -divisor;
1D62  1E10     COMF 0x10, F, ACCESS
1D64  1E0F     COMF i, F, ACCESS
1D66  1E0E     COMF c, F, ACCESS
1D68  1E0D     COMF 0xD, F, ACCESS
1D6A  1E0C     COMF fp, F, ACCESS
1D6C  1E0B     COMF csize, F, ACCESS
1D6E  1E0A     COMF s, F, ACCESS
1D70  6C09     NEGF divisor, ACCESS
1D72  0E00     MOVLW 0x0
1D74  220A     ADDWFC s, F, ACCESS
1D76  220B     ADDWFC csize, F, ACCESS
1D78  220C     ADDWFC fp, F, ACCESS
1D7A  220D     ADDWFC 0xD, F, ACCESS
1D7C  220E     ADDWFC c, F, ACCESS
1D7E  220F     ADDWFC i, F, ACCESS
1D80  2210     ADDWFC 0x10, F, ACCESS
18:            		sign = 1;
1D82  0E01     MOVLW 0x1
1D84  6E12     MOVWF sign, ACCESS
19:            	}
20:            	if(dividend < 0) {
1D86  AE08     BTFSS s, 7, ACCESS
1D88  D012     BRA 0x1DAE
21:            		dividend = -dividend;
1D8A  1E08     COMF s, F, ACCESS
1D8C  1E07     COMF c, F, ACCESS
1D8E  1E06     COMF 0x6, F, ACCESS
1D90  1E05     COMF product, F, ACCESS
1D92  1E04     COMF data, F, ACCESS
1D94  1E03     COMF fp, F, ACCESS
1D96  1E02     COMF 0x2, F, ACCESS
1D98  6C01     NEGF __pcstackCOMRAM, ACCESS
1D9A  0E00     MOVLW 0x0
1D9C  2202     ADDWFC 0x2, F, ACCESS
1D9E  2203     ADDWFC fp, F, ACCESS
1DA0  2204     ADDWFC data, F, ACCESS
1DA2  2205     ADDWFC product, F, ACCESS
1DA4  2206     ADDWFC 0x6, F, ACCESS
1DA6  2207     ADDWFC c, F, ACCESS
1DA8  2208     ADDWFC s, F, ACCESS
22:            		sign ^= 1;
1DAA  0E01     MOVLW 0x1
1DAC  1A12     XORWF sign, F, ACCESS
23:            	}
24:            	quotient = 0;
1DAE  EE20     LFSR 2, 0x13
1DB0  F013     NOP
1DB2  0E07     MOVLW 0x7
1DB4  6ADE     CLRF POSTINC2, ACCESS
1DB6  06E8     DECF WREG, F, ACCESS
1DB8  E2FD     BC 0x1DB4
25:            	if(divisor != 0) {
1DBA  5009     MOVF divisor, W, ACCESS
1DBC  100A     IORWF s, W, ACCESS
1DBE  100B     IORWF csize, W, ACCESS
1DC0  100C     IORWF fp, W, ACCESS
1DC2  100D     IORWF 0xD, W, ACCESS
1DC4  100E     IORWF c, W, ACCESS
1DC6  100F     IORWF i, W, ACCESS
1DC8  1010     IORWF 0x10, W, ACCESS
1DCA  B4D8     BTFSC STATUS, 2, ACCESS
1DCC  D046     BRA 0x1E5A
26:            		counter = 1;
1DCE  0E01     MOVLW 0x1
1DD0  6E11     MOVWF counter, ACCESS
27:            		while((divisor & 0x8000000000000000ULL) == 0) {
1DD2  D00A     BRA 0x1DE8
1DE8  AE10     BTFSS 0x10, 7, ACCESS
1DEA  D7F4     BRA 0x1DD4
28:            			divisor <<= 1;
1DD4  90D8     BCF STATUS, 0, ACCESS
1DD6  3609     RLCF divisor, F, ACCESS
1DD8  360A     RLCF s, F, ACCESS
1DDA  360B     RLCF csize, F, ACCESS
1DDC  360C     RLCF fp, F, ACCESS
1DDE  360D     RLCF 0xD, F, ACCESS
1DE0  360E     RLCF c, F, ACCESS
1DE2  360F     RLCF i, F, ACCESS
1DE4  3610     RLCF 0x10, F, ACCESS
29:            			counter++;
1DE6  2A11     INCF counter, F, ACCESS
30:            		}
31:            		do {
32:            			quotient <<= 1;
1DEC  90D8     BCF STATUS, 0, ACCESS
1DEE  3613     RLCF quotient, F, ACCESS
1DF0  3614     RLCF 0x14, F, ACCESS
1DF2  3615     RLCF p, F, ACCESS
1DF4  3616     RLCF i, F, ACCESS
1DF6  3617     RLCF 0x17, F, ACCESS
1DF8  3618     RLCF w, F, ACCESS
1DFA  3619     RLCF counter, F, ACCESS
1DFC  361A     RLCF cp, F, ACCESS
33:            			if((unsigned long long)divisor <= (unsigned long long)dividend) {
1DFE  5009     MOVF divisor, W, ACCESS
1E00  5C01     SUBWF __pcstackCOMRAM, W, ACCESS
1E02  500A     MOVF s, W, ACCESS
1E04  5802     SUBWFB 0x2, W, ACCESS
1E06  500B     MOVF csize, W, ACCESS
1E08  5803     SUBWFB fp, W, ACCESS
1E0A  500C     MOVF fp, W, ACCESS
1E0C  5804     SUBWFB data, W, ACCESS
1E0E  500D     MOVF 0xD, W, ACCESS
1E10  5805     SUBWFB product, W, ACCESS
1E12  500E     MOVF c, W, ACCESS
1E14  5806     SUBWFB 0x6, W, ACCESS
1E16  500F     MOVF i, W, ACCESS
1E18  5807     SUBWFB c, W, ACCESS
1E1A  5010     MOVF 0x10, W, ACCESS
1E1C  5808     SUBWFB s, W, ACCESS
1E1E  A0D8     BTFSS STATUS, 0, ACCESS
1E20  D011     BRA 0x1E44
34:            				dividend -= divisor;
1E22  5009     MOVF divisor, W, ACCESS
1E24  5E01     SUBWF __pcstackCOMRAM, F, ACCESS
1E26  500A     MOVF s, W, ACCESS
1E28  5A02     SUBWFB 0x2, F, ACCESS
1E2A  500B     MOVF csize, W, ACCESS
1E2C  5A03     SUBWFB fp, F, ACCESS
1E2E  500C     MOVF fp, W, ACCESS
1E30  5A04     SUBWFB data, F, ACCESS
1E32  500D     MOVF 0xD, W, ACCESS
1E34  5A05     SUBWFB product, F, ACCESS
1E36  500E     MOVF c, W, ACCESS
1E38  5A06     SUBWFB 0x6, F, ACCESS
1E3A  500F     MOVF i, W, ACCESS
1E3C  5A07     SUBWFB c, F, ACCESS
1E3E  5010     MOVF 0x10, W, ACCESS
1E40  5A08     SUBWFB s, F, ACCESS
35:            				quotient |= 1;
1E42  8013     BSF quotient, 0, ACCESS
36:            			}
37:            			*(unsigned long long int *)&divisor >>= 1;
1E44  90D8     BCF STATUS, 0, ACCESS
1E46  3210     RRCF 0x10, F, ACCESS
1E48  320F     RRCF i, F, ACCESS
1E4A  320E     RRCF c, F, ACCESS
1E4C  320D     RRCF 0xD, F, ACCESS
1E4E  320C     RRCF fp, F, ACCESS
1E50  320B     RRCF csize, F, ACCESS
1E52  320A     RRCF s, F, ACCESS
1E54  3209     RRCF divisor, F, ACCESS
38:            		} while(--counter != 0);
1E56  2E11     DECFSZ counter, F, ACCESS
1E58  D7C9     BRA 0x1DEC
39:            	}
40:            	if(sign)
1E5A  5012     MOVF sign, W, ACCESS
1E5C  B4D8     BTFSC STATUS, 2, ACCESS
1E5E  D010     BRA 0x1E80
41:            		quotient = -quotient;
1E60  1E1A     COMF cp, F, ACCESS
1E62  1E19     COMF counter, F, ACCESS
1E64  1E18     COMF w, F, ACCESS
1E66  1E17     COMF 0x17, F, ACCESS
1E68  1E16     COMF i, F, ACCESS
1E6A  1E15     COMF p, F, ACCESS
1E6C  1E14     COMF 0x14, F, ACCESS
1E6E  6C13     NEGF quotient, ACCESS
1E70  0E00     MOVLW 0x0
1E72  2214     ADDWFC 0x14, F, ACCESS
1E74  2215     ADDWFC p, F, ACCESS
1E76  2216     ADDWFC i, F, ACCESS
1E78  2217     ADDWFC 0x17, F, ACCESS
1E7A  2218     ADDWFC w, F, ACCESS
1E7C  2219     ADDWFC counter, F, ACCESS
1E7E  221A     ADDWFC cp, F, ACCESS
42:            	return quotient;
1E80  C013     MOVFF quotient, __pcstackCOMRAM
1E82  F001     NOP
1E84  C014     MOVFF 0x14, 0x2
1E86  F002     NOP
1E88  C015     MOVFF p, fp
1E8A  F003     NOP
1E8C  C016     MOVFF i, data
1E8E  F004     NOP
1E90  C017     MOVFF 0x17, product
1E92  F005     NOP
1E94  C018     MOVFF w, 0x6
1E96  F006     NOP
1E98  C019     MOVFF counter, c
1E9A  F007     NOP
1E9C  C01A     MOVFF cp, s
1E9E  F008     NOP
43:            }
1EA0  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/abs.c  ---------------------------
1:             int abs(int a)
2:             {
3:             	return a>0 ? a : -a;
2A40  BE14     BTFSC 0x14, 7, ACCESS
2A42  D005     BRA 0x2A4E
2A44  5014     MOVF 0x14, W, ACCESS
2A46  E110     BNZ 0x2A68
2A48  0413     DECF quotient, W, ACCESS
2A4A  B0D8     BTFSC STATUS, 0, ACCESS
2A4C  D00D     BRA 0x2A68
2A4E  C013     MOVFF quotient, p
2A50  F015     NOP
2A52  C014     MOVFF 0x14, i
2A54  F016     NOP
2A56  1E15     COMF p, F, ACCESS
2A58  1E16     COMF i, F, ACCESS
2A5A  4A15     INFSNZ p, F, ACCESS
2A5C  2A16     INCF i, F, ACCESS
2A5E  C015     MOVFF p, quotient
2A60  F013     NOP
2A62  C016     MOVFF i, 0x14
2A64  F014     NOP
2A66  0012     RETURN 0
2A68  C013     MOVFF quotient, quotient
2A6A  F013     NOP
2A6C  C014     MOVFF 0x14, 0x14
2A6E  F014     NOP
4:             }
2A70  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/Umul16.c  ------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned int
15:            __wmul(unsigned int multiplier, unsigned int multiplicand)
16:            {
17:                    unsigned int product;
18:            
19:            #if _Has_hardware_multiply || _Has_large_call_stack
20:            
21:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:            
24:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:            /*
26:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                   a  b
28:            *      c  d
29:            -----------
30:                 |   bd
31:                 |ad  0
32:                 |bc  0
33:            +  ac| 0  0 (we ignore this intermediate product
34:                         because it does not affect the low 16 bits of the result)
35:            ===========
36:             */
37:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
2B5C  5001     MOVF __pcstackCOMRAM, W, ACCESS
2B5E  0203     MULWF fp, ACCESS
2B60  CFF3     MOVFF PROD, product
2B62  F005     NOP
2B64  CFF4     MOVFF PRODH, 0x6
2B66  F006     NOP
38:                    product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
2B68  5001     MOVF __pcstackCOMRAM, W, ACCESS
2B6A  0204     MULWF data, ACCESS
2B6C  50F3     MOVF PROD, W, ACCESS
2B6E  2606     ADDWF 0x6, F, ACCESS
39:                    product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
2B70  5002     MOVF 0x2, W, ACCESS
2B72  0203     MULWF fp, ACCESS
2B74  50F3     MOVF PROD, W, ACCESS
2B76  2606     ADDWF 0x6, F, ACCESS
40:            
41:            #else
42:            
43:            	product = 0;
44:            	do {
45:            		if(multiplier & 1)
46:            			product += multiplicand;
47:            		multiplicand <<= 1;
48:            		multiplier >>= 1;
49:            	} while(multiplier != 0);
50:            
51:            #endif
52:                    return product;
2B78  C005     MOVFF product, __pcstackCOMRAM
2B7A  F001     NOP
2B7C  C006     MOVFF 0x6, 0x2
2B7E  F002     NOP
53:            }
2B80  0012     RETURN 0
